#!/usr/bin/perl
# (c) 2008 Neil Christensen
# version 0.85
# See version notes in README
use File::stat;
use Time::localtime;
use Getopt::Std;
%options=();
getopts("nrf:",\%options);

####################################################
#               Global variables                   #
####################################################
$sleep_time=3;
$batch_file_name="";
#$batch_file_name=$options{f} if defined $options{f};
$batch_file_name=$ARGV[0] if defined $ARGV[0];
$working_dir="";
@models = ();
$model_num=0;
$model_name = "";
$model_url  = "";
$gauge = "Feynman";
@mod_dirs = ();
@mod_names = ();
@lib_dirs = ();
$next_lib_dir=0;
@lib_procs = ();
@lib_removes = ();
@processes = ();
@decays = ();
@removes = ();
@removesNumber = ();
@partons = ();
$n_subs=0;
@subprocesses = ();
@subproc_which_proc = ();
@subproc_dir = ();
@subproc_in_lib = ();
@subremoves=();
$n_decay_subs=0;
@decay_subprocesses = ();
@decay_subproc_which_decay = ();
@decay_subproc_dir = ();
@decay_subproc_in_lib = ();
@decay_subremoves = ();
$widths_dir="";
$widths_in_lib=0;
@all_subprocesses = ();
@all_subproc_dir = ();
@all_subproc_in_lib = ();
$pdf1="";
$pdf2="";
$pdf1_name="\"OFF\"";
$pdf2_name="\"OFF\"";
$bunch_size   = 560;
$bunch_length = 0.4;
$bunch_number = 2E+10;
$photon_particle                 = "e^+";
$photon_Qmax                     = 100;
$photon_incoming_particle_mass   = 0.938;
$photon_incoming_particle_charge = 1;
$photon_Q2max                    = 2;
$photon_proton_ptCut             = 0.1;
$p1=7000;
$p2=7000;
@param_names=();
@param_values=();
@vars_names=();
@vars_values=();
@run_param = ();
@run_begin = ();
@run_step  = ();
@run_n     = ();
$alphaPDF  = "On";
$alphaMZ   = 0.1172;
$alphaNF   = 5;
$alphaOrder= 2;
$alphaMbMb = 4.2;
$alphaMtp  = 175;
@alphaScale= ();
@alphaNumber=();
@cut_param = ();
@cut_Number= ();
@cut_invert= ();
@cut_min   = ();
@cut_max   = ();
@kinematics= ();
@kin_Number= ();
@decay_kinematics= ();
@decay_kin_Number= ();
@reg_mom   = ();
@reg_Number= ();
@reg_mass  = ();
@reg_width = ();
@reg_pow   = ();
@dist_param = ();
@dist_Number= ();
@dist_min   = ();
@dist_max   = ();
@dist_title = ();
@dist_x_title=();
@dist_n_bins= ();
@dist_filenames = ();
@plot_filenames = ();
$n_events  = 0;
$fileName = "";
$fileFormat = "";
$ntuple    = "False";
$cleanup   = "True";
$par_meth  = "this computer";
$max_cpus  = 1;
$que       = "";
$walltime  = 0;
$memory    = 0;
$email     = "";
$LSFproject = "";
$nice_level=19;
@pids      = ();
$symb_begin_time = 0;
$symb_end_time = 0;
$cs_begin_time = 0;
$cs_end_time = 0;
@cs = ();
@cs_tot = ();
@final_cs = ();
$events_begin_time = 0;
$events_end_time = 0;
@event_filenames = ();
$nSess1 = 5;
$nCalls1 = 10000;
$nSess2 = 0;
$nCalls2 = 10000;
$subCubes = 1000;
$randSearch = 100;
$simpSearch = 50;
$maxN = "2.000000";
$findNewMax = 50;
$randTime = time();

#Get current directory
chomp($working_dir = `pwd`);
$html_dir="$working_dir/html";
$CH_PATH=$ENV{'CALCHEP'};
if($CH_PATH eq ""){$CH_PATH=$working_dir;}
#print "$CH_PATH\n";
#print "$ARGV[0]\n";



####################################################
#               Read batch file.                   #
####################################################
print_index(-1);
#Check to see if the batch file is present.
#If not,  warn the user.
if (!(-e $batch_file_name)) {
  print_no_batch_file();
  if (!(-d $html_dir)){system("mkdir $html_dir");}
  if (!(-e "$html_dir/style.css")){print_style_file();}
  if (!(-d "$html_dir/runs")){system("mkdir $html_dir/runs");}
  #if (-d "$html_dir/help"){system("rm -r $html_dir/help");}
  if (!(-d "$html_dir/help")){
    system("mkdir $html_dir/help");
    print_help();
  }
  exit();
}
#Tell the user we are processing batch.
print("\n\nProcessing batch:\n");
#Open and process batch_file.
open(BATCH_FILE, "<$batch_file_name");
LINE: while($line = <BATCH_FILE>){
	if ($line =~ /^#/){next LINE;}
	elsif ($line =~ /html\s*dir[^:]*:([^:]*)/){$html_dir=$1;$html_dir=~s/\s//g;}
#	elsif ($line =~ /Model\s*:\s*(\d+)/){$model_num=$1;$model_num =~ s/\s//g;}
	elsif ($line =~ /Model\s*:\s*([^:]+)/){$model_name=$1;}
	elsif ($line =~ /Model changed\s*:\s*(\w+)/){$model_changed=$1;$model_changed =~ s/\s//g;}
	elsif ($line =~ /Gauge\s*:\s*(\w+)/){$gauge=$1;$gauge =~ s/\s//g;}
	elsif ($line =~ /Process\s*:\s*([^\s]+)/){$tmp=$1;$tmp =~ s/\s//g;push(@processes,$tmp);}
	elsif ($line =~ /Decay\s*:(.+)/){$tmp=$1;$tmp =~ s/\s//g;push(@decays,$tmp);}
	elsif ($line =~ /[Rr]emove[^:]*:\s*([0-9]*)\s*:([^:]*)/){push(@removesNumber,$1);$tmp=$2;$tmp =~ s/\s//g;push(@removes,$tmp)}
	elsif ($line =~ /[Rr]emove[^:]*:([^:]*)/){push(@removesNumber,-1);$tmp=$1;$tmp =~ s/\s//g;push(@removes,join(",",sort(split(",",$tmp))));}
	elsif ($line =~ /Composite\s*:([^:]+)/){$tmp=$1;$tmp =~ s/\s//g;push(@partons,$tmp);}
	elsif ($line =~ /pdf1\s*:\s*([^:]+)/){$pdf1=$1;$pdf1 =~ s/\s//g;}
	elsif ($line =~ /pdf2\s*:\s*([^:]+)/){$pdf2=$1;$pdf2 =~ s/\s//g;}
	elsif ($line =~ /[Bb]unch[^:]*[Ss]ize[^:]*:([^:]+)/){$bunch_size = $1;$bunch_size =~ s/\s//g;}
	elsif ($line =~ /[Bb]unch[^:]*[Ll]ength[^:]*:([^:]+)/){$bunch_length = $1;$bunch_length =~ s/\s//g;}
	elsif ($line =~ /[Nn]umber[^:]*[Pp]article[^:]*:([^:]+)/){$bunch_number = $1;$bunch_number =~ s/\s//g;}
	elsif ($line =~ /[Pp]hoton[^:]*[Pp]article[^:]*:([^:]+)/){$photon_particle = $1;$photon_particle =~ s/\s//g;}
	elsif ($line =~ /\|Q\|\s*max[^:]*:([^:]+)/){$photon_Qmax = $1; $photon_Qmax =~ s/\s//g;}
	elsif ($line =~ /[Ii]ncoming\s*particle\s*mass[^:]*:([^:]+)/){$photon_incoming_particle_mass = $1;$photon_incoming_particle_mass =~ s/\s//g;}
	elsif ($line =~ /[Ii]ncoming\s*particle\s*charge[^:]*:([^:]+)/){$photon_incoming_particle_charge = $1;$photon_incoming_particle_charge =~ s/\s//g;}
	elsif ($line =~ /\|Q\^2\|\s*max[^:]*:([^:]+)/){$photon_Q2max = $1;$photon_Q2max =~ s/\s//g;}
	elsif ($line =~ /Pt\s*cut[^:]*proton[^:]*:([^:]+)/){$photon_proton_ptCut = $1;$photon_proton_ptCut =~ s/\s//g;}
	elsif ($line =~ /p1\s*:\s*(\d+)/){$p1=$1;$p1 =~ s/\s//g;}
	elsif ($line =~ /p2\s*:\s*(\d+)/){$p2=$1;$p2 =~ s/\s//g;}
	elsif ($line =~ /Parameter\s*:\s*([^=]+)=([^=]+)/){
		$tmp1=$1;$tmp2=$2;
		$tmp1=~ s/\s//g;$tmp2 =~ s/\s//g;
		push(@param_names,$tmp1);
		push(@param_values,$tmp2);
	}
	elsif ($line =~ /Run parameter\s*:\s*([^\s]+)/){$tmp=$1;$tmp =~ s/\s//g;push(@run_param,$tmp);}
	elsif ($line =~ /Run begin\s*:\s*([^\s]+)/){$tmp=$1;$tmp =~ s/\s//g;push(@run_begin,$tmp);}
	elsif ($line =~ /Run step size\s*:\s*([^\s]+)/){$tmp=$1;$tmp =~ s/\s//g;push(@run_step,$tmp);}
	elsif ($line =~ /Run n steps\s*:\s*([^\s]+)/){$tmp=$1;$tmp =~ s/\s//g;push(@run_n,$tmp);}
	elsif ($line =~ /parton\s*dist[^:]*:([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;$alphaPDF  = $tmp;}
	elsif ($line =~ /alpha\s*\(MZ\)[^:]*:([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;$alphaMZ  = $tmp;}
	elsif ($line =~ /alpha\s*nf[^:]*:([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;$alphaNF  = int($tmp);}
	elsif ($line =~ /alpha\s*[Oo]rder[^:]*:([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;$alphaOrder  = $tmp;}
	elsif ($line =~ /mb\s*\(mb\)[^:]*:([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;$alphaMbMb  = $tmp;}
	elsif ($line =~ /Mtop\s*\(pole\)[^:]*:([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;$alphaMtp  = $tmp;}
	elsif ($line =~ /alpha\s*Q[^:]*:\s*([0-9]*)\s*:([^:]*)/){push(@alphaNumber,$1-1);$tmp=$2;$tmp =~ s/\s//g;push(@alphaScale,$tmp);}
	elsif ($line =~ /alpha\s*Q[^:]*:([^:]*)/){push(@alphaNumber,-1);$tmp=$1;$tmp =~ s/\s//g;push(@alphaScale,$tmp);}
	elsif ($line =~ /Cut parameter\s*:\s*([0-9]*)\s*:\s*([^\s]+)/){push(@cut_Number,$1-1);$tmp=$2;$tmp =~ s/\s//g;push(@cut_param,$tmp);}
	elsif ($line =~ /Cut parameter\s*:\s*([^:]+)/){push(@cut_Number,-1);$tmp=$1;$tmp =~ s/\s//g;push(@cut_param,$tmp);}
	elsif ($line =~ /Cut inver[^:]*:\s*([0-9]*)\s*:\s*([^:]*)/){$tmp=$2;$tmp =~ s/\s//g;push(@cut_invert,$tmp);}
	elsif ($line =~ /Cut inver[^:]*:\s*([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;push(@cut_invert,$tmp);}
	elsif ($line =~ /Cut min\s*:\s*([0-9]*)\s*:\s*([^:]*)/){$tmp=$2;$tmp =~ s/\s//g;push(@cut_min,$tmp);}
	elsif ($line =~ /Cut min\s*:\s*([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;push(@cut_min,$tmp);}
	elsif ($line =~ /Cut max\s*:\s*([0-9]*)\s*:\s*([^:]*)/){$tmp=$2;$tmp =~ s/\s//g;push(@cut_max,$tmp);}
	elsif ($line =~ /Cut max\s*:\s*([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;push(@cut_max,$tmp);}
	elsif ($line =~ /[Dd]ecay\s*[Kk]inematics\s*:\s*([0-9]*)\s*:\s*([^:]+)/){push(@decay_kin_Number,$1-1);$tmp=$2;$tmp =~ s/\s//g;push(@decay_kinematics,$tmp);}
	elsif ($line =~ /[Dd]ecay\s*[Kk]inematics\s*:\s*([^:]+)/){push(@decay_kin_Number,-1);$tmp=$1;$tmp =~ s/\s//g;push(@decay_kinematics,$tmp);}
	elsif ($line =~ /[Kk]inematics\s*:\s*([0-9]*)\s*:\s*([^:]+)/){push(@kin_Number,$1-1);$tmp=$2;$tmp =~ s/\s//g;push(@kinematics,$tmp);}
	elsif ($line =~ /[Kk]inematics\s*:\s*([^:]+)/){push(@kin_Number,-1);$tmp=$1;$tmp =~ s/\s//g;push(@kinematics,$tmp);}
	elsif ($line =~ /Regularization momentum\s*:\s*([0-9]*)\s*:\s*([^\s]+)/){push(@reg_Number,$1-1);$tmp=$2;$tmp =~ s/\s//g;push(@reg_mom,$tmp);}
	elsif ($line =~ /Regularization momentum\s*:\s*([^:]+)/){push(@reg_Number,-1);$tmp=$1;$tmp =~ s/\s//g;push(@reg_mom,$tmp);}
	elsif ($line =~ /Regularization mass\s*:\s*([0-9]*)\s*:\s*([^\s]+)/){$tmp=$2;$tmp =~ s/\s//g;push(@reg_mass,$tmp);}
	elsif ($line =~ /Regularization mass\s*:\s*([^:]+)/){$tmp=$1;$tmp =~ s/\s//g;push(@reg_mass,$tmp);}
	elsif ($line =~ /Regularization width\s*:\s*([0-9]*)\s*:\s*([^\s]+)/){$tmp=$2;$tmp =~ s/\s//g;push(@reg_width,$tmp);}
	elsif ($line =~ /Regularization width\s*:\s*([^:]+)/){$tmp=$1;$tmp =~ s/\s//g;push(@reg_width,$tmp);}
	elsif ($line =~ /Regularization power\s*:\s*([0-9]*)\s*:\s*([^\s]+)/){$tmp=$2;$tmp =~ s/\s//g;push(@reg_pow,$tmp);}
	elsif ($line =~ /Regularization power\s*:\s*([^:]+)/){$tmp=$1;$tmp =~ s/\s//g;push(@reg_pow,$tmp);}
	elsif ($line =~ /Dist parameter\s*:\s*([0-9]*)\s*:\s*([^\s]+)/){push(@dist_Number,$1-1);$tmp=$2;$tmp =~ s/\s//g;push(@dist_param,$tmp);}
	elsif ($line =~ /Dist parameter\s*:\s*([^:]+)/){push(@dist_Number,-1);$tmp=$1;$tmp =~ s/\s//g;push(@dist_param,$tmp);}
	elsif ($line =~ /Dist min\s*:\s*([0-9]*)\s*:\s*([^:]*)/){$tmp=$2;$tmp =~ s/\s//g;push(@dist_min,$tmp);}
	elsif ($line =~ /Dist min\s*:\s*([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;push(@dist_min,$tmp);}
	elsif ($line =~ /Dist max\s*:\s*([0-9]*)\s*:\s*([^:]*)/){$tmp=$2;$tmp =~ s/\s//g;push(@dist_max,$tmp);}
	elsif ($line =~ /Dist max\s*:\s*([^:]*)/){$tmp=$1;$tmp =~ s/\s//g;push(@dist_max,$tmp);}
	elsif ($line =~ /Dist title\s*:\s*([0-9]*)\s*:\s*([^:]*)\s*/){$tmp=$2;$tmp =~ s/\n//g;push(@dist_title,$tmp);}
	elsif ($line =~ /Dist title\s*:\s*([^:]*)\s*/){$tmp=$1;$tmp =~ s/\n//g;push(@dist_title,$tmp);}
	elsif ($line =~ /Dist x-title\s*:\s*([0-9]*)\s*:\s*([^:]*)\s*/){$tmp=$2;$tmp =~ s/\n//g;push(@dist_x_title,$tmp);}
	elsif ($line =~ /Dist x-title\s*:\s*([^:]*)\s*/){$tmp=$1;$tmp =~ s/\n//g;push(@dist_x_title,$tmp);}
	elsif ($line =~ /Dist n bins\s*:\s*([0-9]*)\s*:\s*([^:]*)\s*/){$tmp=$2;push(@dist_n_bins,int($tmp));}
	elsif ($line =~ /Dist n bins\s*:\s*([^:]*)\s*/){$tmp=$1;push(@dist_n_bins,int($tmp));}
	elsif ($line =~ /Number of events[^:]*:\s*([^\s]+)/){$n_events=$1;}
	elsif ($line =~ /[Ff]ile\s*[Nn]ame[^:]*:\s*([^\s]+)/){$fileName=$1;}
	elsif ($line =~ /[Ff]ile\s*[Ff]ormat[^:]*:\s*([^\s]+)/){$fileFormat=$1;}
	elsif ($line =~ /[Nn][Tt]uple[^:]*:\s*([^\s]+)/){$ntuple = $1;$ntuple =~ s/\s//g;}
	elsif ($line =~ /[Cc]lean\s*[Uu]p[^:]*:([^:]+)/){$cleanup=$1;$cleanup =~ s/\s//g;}
	elsif ($line =~ /Parallel[^:]*:\s*([^:]+)/){$par_meth=$1;$par_meth =~ s/\n//g;}
	elsif ($line =~ /Que[^:]*:([^:]+)/){$que=$1;$que =~ s/\s//g;}
	elsif ($line =~ /[Ww]alltime[^:]*:([^:]+)/){$walltime=$1; $walltime =~ s/\s//g;}
	elsif ($line =~ /[Mm]emory[^:]*:([^:]+)/  ){$memory=$1;   $memory   =~ s/\s//g;}
	elsif ($line =~ /email[^:]*:([^:]+)/){$email=$1;$email =~ s/\s//g;}
	elsif ($line =~ /[Pp]roject[^:]*:([^:]+)/){$LSFproject=$1; $LSFproject=~s/\s//g;}
	elsif ($line =~ /Max[^:]+cpus[^:]*:\s*([^\s]+)/){$max_cpus=$1; $max_cpus =~ s/\s//g; $max_cpus = int($max_cpus);}
	elsif ($line =~ /[Nn]ice\s*[Ll]evel[^:]*:\s*([^:]+)/){$nice_level=$1; $nice_level =~ s/\s//g; $nice_level = int($nice_level);}
	elsif ($line =~ /nSess_1\s*:\s*([0-9]*)/){$nSess1=$1;$nSess1 =~ s/\s//g; $nSess1=int($nSess1);}
	elsif ($line =~ /nSess_2\s*:\s*([0-9]*)/){$nSess2=$1;$nSess2 =~ s/\s//g; $nSess2=int($nSess2);}
	elsif ($line =~ /nCalls_1\s*:\s*([0-9]*)/){$nCalls1=$1;$nCalls1 =~ s/\s//g; $nCalls1=int($nCalls1);}
	elsif ($line =~ /nCalls_2\s*:\s*([0-9]*)/){$nCalls2=$1;$nCalls2 =~ s/\s//g; $nCalls2=int($nCalls2);}
	elsif ($line =~ /sub-cubes\s*:\s*([0-9]*)/){$subCubes=$1;$subCubes =~ s/\s//g; $subCubes=int($subCubes);}
	elsif ($line =~ /random\s*search\s*:\s*([0-9]*)/){$randSearch=$1;$randSearch =~ s/\s//g; $randSearch=int($randSearch);}
	elsif ($line =~ /simplex\s*search\s*:\s*([0-9]*)/){$simpSearch=$1;$simpSearch =~ s/\s//g; $simpSearch=int($simpSearch);}
	elsif ($line =~ /max\*N\s*:\s*([^:]*)/){$maxN=$1;$maxN =~ s/\s//g;$maxN=sprintf("%.6f",$maxN);}
	elsif ($line =~ /find\s*new\s*MAX\s*:\s*([0-9]*)/){$findNewMax=$1;$findNewMax =~ s/\s//g; $findNewMax=int($findNewMax);}
	elsif ($line =~ /[Ss]leep\s*[Tt]ime\s*:\s*([0-9]*)/){$sleep_time=$1;$sleep_time =~ s/\s//g; $sleep_time=int($sleep_time);}
	
		
}
close(BATCH_FILE);

####################################################
#     Make sure directories are in place.          #
####################################################
if (!(-d "Events")){system("mkdir Events");}
if (!(-d "Events/tmp")){system("mkdir Events/tmp");}
if (!(-d $html_dir)){system("mkdir $html_dir");}
if (!(-e "$html_dir/style.css")){print_style_file();}
if (!(-d "$html_dir/runs")){system("mkdir $html_dir/runs");}
#if (-d "$html_dir/help"){system("rm -r $html_dir/help");}
if (!(-d "$html_dir/help")){
	system("mkdir $html_dir/help");
	print_help();
}
#Tell the user to look in html/index for progress
print("Progress information can be found in the html directory.\nSimply open the following link in your browser:\nfile://${html_dir}/index.html\nYou can also view textual progress reports in ${html_dir}/index.txt\n\tand the other .txt files in the html directory.\nEvents will be stored in the Events directory.\n\n");
#print "Done printing help\n";
#exit();


####################################################
#           Determine pdf name                     #
####################################################
if    ($pdf1 =~ /cteq6l[\s\(]*anti-proton/)     {$pdf1_name="\"PDT:cteq6l(anti-proton)\" -2212";}
elsif ($pdf1 =~ /cteq6l[\s\(]*proton/)          {$pdf1_name="\"PDT:cteq6l(proton)\" 2212";}
elsif ($pdf1 =~ /mrst2002lo[\s\(]*anti-proton/) {$pdf1_name="\"PDT:mrst2002lo(anti-proton)\" -2212";}
elsif ($pdf1 =~ /mrst2002lo[\s\(]*proton/)      {$pdf1_name="\"PDT:mrst2002lo(proton)\" 2212";}
elsif ($pdf1 =~ /cteq6m[\s\(]*anti-proton/)     {$pdf1_name="\"PDT:cteq6m(anti-proton)\" -2212";}
elsif ($pdf1 =~ /cteq6m[\s\(]*proton/)          {$pdf1_name="\"PDT:cteq6m(proton)\" 2212";}
elsif ($pdf1 =~ /cteq5m[\s\(]*anti-proton/)     {$pdf1_name="\"PDT:CTEQ5M(anti-proton)\" -2212";}
elsif ($pdf1 =~ /cteq5m[\s\(]*proton/)          {$pdf1_name="\"PDT:CTEQ5M(proton)\" 2212";}
elsif ($pdf1 =~ /mrst2002nlo[\s\(]*anti-proton/){$pdf1_name="\"PDT:mrst2002nlo(anti-proton)\" -2212";}
elsif ($pdf1 =~ /mrst2002nlo[\s\(]*proton/)     {$pdf1_name="\"PDT:mrst2002nlo(proton)\" 2212";}
elsif ($pdf1 =~ /[Ii][Ss][Rr].*[Bb]eam/)        {$pdf1_name=sprintf("\"ISR(1.00S^.5 Beamstr.: %.1f,%.3f,%.1E )\"",$bunch_size,$bunch_length,$bunch_number);}
elsif ($pdf1 =~ /[Ii][Ss][Rr]/)                 {$pdf1_name="\"ISR(1.00S^.5 Beamstr.: OFF)\"";}
elsif ($pdf1 =~ /[Ee]quiv[^:]*[Pp]hoton/)       {$pdf1_name=sprintf("\"Equiv.Photon(particle= %s |Q|max=%s)\" 11",$photon_particle,$photon_Qmax);}
elsif ($pdf1 =~ /[Ll]aser[^:]*[Pp]hoton/)       {$pdf1_name="\"Laser photons\" 22";}
elsif ($pdf1 =~ /[Pp]roton[^:]*[Pp]hoton/)      {$pdf1_name=sprintf("\"Proton.Photon(m=%f Ch=%i Q=%f Pt>%f)\" -2212",
																		$photon_incoming_particle_mass,$photon_incoming_particle_charge, $photon_Q2max, $photon_proton_ptCut);}
else                                            {$pdf1_name="\"OFF\"";}

if    ($pdf2 =~ /cteq6l[\s\(]*anti-proton/)     {$pdf2_name="\"PDT:cteq6l(anti-proton)\" -2212";}
elsif ($pdf2 =~ /cteq6l[\s\(]*proton/)          {$pdf2_name="\"PDT:cteq6l(proton)\" 2212";}
elsif ($pdf2 =~ /mrst2002lo[\s\(]*anti-proton/) {$pdf2_name="\"PDT:mrst2002lo(anti-proton)\" -2212";}
elsif ($pdf2 =~ /mrst2002lo[\s\(]*proton/)      {$pdf2_name="\"PDT:mrst2002lo(proton)\" 2212";}
elsif ($pdf2 =~ /cteq6m[\s\(]*anti-proton/)     {$pdf2_name="\"PDT:cteq6m(anti-proton)\" -2212";}
elsif ($pdf2 =~ /cteq6m[\s\(]*proton/)          {$pdf2_name="\"PDT:cteq6m(proton)\" 2212";}
elsif ($pdf2 =~ /cteq5m[\s\(]*anti-proton/)     {$pdf2_name="\"PDT:CTEQ5M(anti-proton)\" -2212";}
elsif ($pdf2 =~ /cteq5m[\s\(]*proton/)          {$pdf2_name="\"PDT:CTEQ5M(proton)\" 2212";}
elsif ($pdf2 =~ /mrst2002nlo[\s\(]*anti-proton/){$pdf2_name="\"PDT:mrst2002nlo(anti-proton)\" -2212";}
elsif ($pdf2 =~ /mrst2002nlo[\s\(]*proton/)     {$pdf2_name="\"PDT:mrst2002nlo(proton)\" 2212";}
elsif ($pdf2 =~ /[Ii][Ss][Rr].*[Bb]eam/)        {$pdf2_name=sprintf("\"ISR(1.00S^.5 Beamstr.: %.1f,%.3f,%.1E )\"",$bunch_size,$bunch_length,$bunch_number);}
elsif ($pdf2 =~ /[Ii][Ss][Rr]/)                 {$pdf2_name="\"ISR(1.00S^.5 Beamstr.: OFF)\"";}
elsif ($pdf2 =~ /[Ee]quiv[^:]*[Pp]hoton/)       {$pdf2_name=sprintf("\"Equiv.Photon(particle= %s |Q|max=%s)\" 11",$photon_particle,$photon_Qmax);}
elsif ($pdf2 =~ /[Ll]aser[^:]*[Pp]hoton/)       {$pdf2_name="\"Laser photons\" 22";}
elsif ($pdf2 =~ /[Pp]roton[^:]*[Pp]hoton/)      {$pdf2_name=sprintf("\"Proton.Photon(m=%f Ch=%i Q=%f Pt>%f)\" -2212",
																		$photon_incoming_particle_mass,$photon_incoming_particle_charge, $photon_Q2max, $photon_proton_ptCut);}
else                                            {$pdf2_name="\"OFF\"";}

####################################################
#               QCD Scale                          #
####################################################
if ($alphaPDF =~ /[Oo][Nn]/ || $alphaPDF =~ /[Tt][Rr][Uu][Ee]/){$alphaPDF=1;}
else {$alphaPDF=0;}
	if ($alphaOrder =~ /[Nn][Nn][Ll][Oo]/){$alphaOrder=3;}
	elsif ($alphaOrder =~ /[Nn][Ll][Oo]/){$alphaOrder=2;}
	elsif ($alphaOrder =~ /[Ll][Oo]/){$alphaOrder=1;}
	else {$alphaOrder=2;}


####################################################
#            Determine model number                #
####################################################
my $ni=1;
while($model_num==0&&$ni<100){
	my $file = "$working_dir/models/prtcls${ni}.mdl";
	if(-e $file){
		open(MDL_FILE,$file) or 
			die("Could not open $file");
		my $line = <MDL_FILE>;
		$line =~ s/\s//g;
		$model_name =~ s/\s//g;
		if($line eq $model_name) {$model_num=$ni;}
		close(MDL_FILE);
	}
	$ni++;
}
if($model_num==0) {die("Could not find model: $model_name.\n");}

####################################################
#                 Load the model                   #
####################################################
my $file = "$working_dir/models/prtcls${model_num}.mdl";
open(MDL_FILE,$file) or
	die ("Could not open $file");
@prtcl_full_names=();
@prtcl_names=();
$model_name = <MDL_FILE>;
$model_name =~ s/\n//g;
LINE: while ($line = <MDL_FILE>){
   if ($line =~ /(Particles|Full  name|=====)/) {next LINE;}
   if ($line =~ /^([^\|]+)\|([^\|]+)\|([^\|]+)\|/) {
   	my $tmp1=$1;my $tmp2=$2;$tmp3=$3;
   	$tmp2 =~ s/\s//g;$tmp3 =~ s/\s//g;
		push(@prtcl_names,$tmp2);	
		push(@prtcl_full_names,$tmp1);		
		if ($tmp2!~/^$tmp3$/) {
			push(@prtcl_names,$tmp3);
			push(@prtcl_full_names,$tmp1);
		}
   }
}
close(MDL_FILE);
#print join(",",@prtcl_names)."\n";

####################################################
#      Read the url of the model                   #
####################################################
my $file = "$working_dir/models/extlib${model_num}.mdl";
open(MDL_FILE,$file) or
	die ("Could not open $file");
LINE: while ($line = <MDL_FILE>){
   if ($line =~ /(http:.*)/) {
   	$model_url=$1;
   }
}
close(MDL_FILE);


####################################################
#       Read Parameter Values                      #
#           from vars.mdl                          #
#       Change it to the value                     #
#           specified in the batch file.           #
####################################################
open(VARS_FILE,"$working_dir/models/vars${model_num}.mdl")
	or die("Could not open $working_dir/models/vars${model_num}.mdl");
VARS_LINE: while (my $line = <VARS_FILE>){
	if ($line =~ /([^\|]+)\|([^\|]+)\|/){
		$name_tmp = $1;
		$value_tmp = $2;
		$name_tmp =~ s/\s//g;
		$value_tmp =~ s/\s//g;
		if ($name_tmp =~ /[Nn]ame/ || $value_tmp =~ /[Vv]alue/){next VARS_LINE;}
		elsif ($name_tmp =~ /^%/){next VARS_LINE;}
		#print "$name_tmp = $value_tmp\n";
		#printf("%s = %.15E\n",$name_tmp,$value_tmp);
		for(my $j=0;$j<=$#param_names;$j++){
			if ($name_tmp eq $param_names[$j]){$value_tmp=$param_values[$j];}
		}
		push(@vars_names,$name_tmp);
		push(@vars_values,$value_tmp);
	}
}
close(VARS_FILE);



####################################################
#              Print batch details.                #
#       This should be updated.                    #
####################################################
print_request();



####################################################
#           Read the models library                #
####################################################
if (!(-d "Processes")){system("mkdir Processes");}
if (!(-e "Processes/models.txt")){print_init_model_library();}
open(MOD_FILE, "<$working_dir/Processes/models.txt");
LINE: while($line = <MOD_FILE>){
	if ($line =~ /^#/){next LINE;}
	if ($line =~ /([^:]+):([^:]+)/){
		$dir=$1;$mod=$2;
		$dir =~ s/\s//g;
		$mod =~ s/\n//g;
		push(@mod_dirs,$dir);
		push(@mod_names,$mod);
	}
}
close(MOD_FILE);

####################################################
#     Delete directories not in the library        #
####################################################
@dirs = `ls $working_dir/Processes`;
DIR: foreach $dir (@dirs){
	$dir =~ s/\s//g;
	if ($dir =~ /models.txt/){next DIR;}
	$in_lib=0;
	foreach $mod_dir (@mod_dirs){
		if ($dir eq $mod_dir){$in_lib=1;}
	}
	if ($in_lib==0){
		system("rm -r $working_dir/Processes/$dir");
	}
}
#print join("",@dirs)."\n";



####################################################
#         Make sure the appropriate                #
#          directories are present                 #
#          Respond to Model Changes                #
####################################################
$model_dir="m$model_num";
push(@mod_dirs,$model_dir);
push(@mod_names,$model_name);
#Respond to Model Changes    
if ($model_changed =~ /[Yy]es/ || $model_changed =~ /[Tt]rue/){
	print_model_changed();
	exit();
}
#Continue setting up directories.
$nm=0;
if (!(-d "Processes/$model_dir")){system("mkdir Processes/$model_dir");$nm=1;}
if ($gauge =~ /[Uu]nitary/){$model_dir=$model_dir."/unitary";}
else {$model_dir=$model_dir."/Feynman";}
if (!(-d "Processes/$model_dir")){system("mkdir Processes/$model_dir");}
if ($nm==1){print_lib_index("m$model_num",$model_name);}
if (!(-e "Processes/$model_dir/processes.txt")){print_init_library();}
if (!(-e "Events/events.txt")){print_init_event_library();}




####################################################
#         Check that the particles requested       #
#        are actually contained in the model.      #
####################################################
@cmpst_names=();
#First check the composites.
foreach $composite (@partons){
	@pieces1 = split("=",$composite);
	push(@cmpst_names,@pieces1[0]);
	@pieces = split(",",$pieces1[1]);
	#print join(" ",@pieces)."\n";
	foreach $piece (@pieces){
		$in_model=0;
		foreach $particle (@prtcl_names){
			if ($piece eq $particle){
				$in_model=1;
			}
		}
		if ($in_model == 0){
			print_particle_not_found($piece);
			exit();
		}
	}
}

#Next check the processes and decays.
foreach $process ((@processes,@decays)){
	@pieces1 = split("->",$process);
	@pieces = split(",",@pieces1[0]);
	push(@pieces,split(",",@pieces1[1]));
	foreach $piece (@pieces){
		$in_model=0;
		foreach $particle (@prtcl_names){
			if ($piece eq $particle){
				$in_model=1;
			}
		}
		foreach $cmpst_name (@cmpst_names){
			if ($piece eq $cmpst_name){
				$in_model=1;
			}
		}
		if ($piece eq "1*x"||$piece eq "2*x"||$piece eq "3*x"||$piece eq "allDec!"){
			$in_model=1;
		}
		if ($in_model == 0){
			print_particle_not_found($piece);
			exit();
		}
	}
}

#Next check the particle removals.
#Actually, I am removing this code.  I am using the users remove line as is to allow for things like u>2 etc..
#So, composite names cannot be used.
#my @removes=();
#foreach $piece (@rmvs){
#  $in_model=0;
#  foreach $particle (@prtcl_names){
#    if ($piece eq $particle){
#      $in_model=1;
#      $in_removes=0;
#      foreach my $rmv (@removes){
#	if ($piece eq $rmv){$in_removes=1;}
#      }
#      if($in_removes==0){push(@removes,$piece);}
#    }
#  }
#  foreach $composite (@partons){
#    ($cmpst_name,$piecesTmp) = split("=",$composite);
#    if ($piece eq $cmpst_name){
#      $in_model=1;
#      @pieces = split(",",$piecesTmp);
#      foreach my $piece (@pieces){
#	$in_removes=0;
#	foreach my $rmv (@removes){
#	  if ($piece eq $rmv){$in_removes=1;}
#	}
#	if($in_removes==0){push(@removes,$piece);}
#      }
#    }
#  }
#  if ($in_model == 0){
#    print_particle_not_found($piece);
#    exit();
#  }
#}
#print "\n\nRemoves = ".join(",",@removes)."\n";
#exit(0);

####################################################
#              Determine subprocesses.             #
#Run calchep with the full process                 #
#Extract the subprocesses from results/list_prc.txt#
####################################################
#                    2->n                          #
####################################################
print_index(0);print_symbolic();
#foreach $process (@processes){
for (my $l=0;$l<=$#processes;$l++){
	my $process = $processes[$l];
	#Run Process
	$systemString = "";
	for (my $j=1;$j<$model_num;$j++){$systemString=$systemString."[";}
	$systemString=$systemString."\{\{$process\{";
	
	#Partons
	@pieces1=split(/->/,$process);
	@pieces2=split(/,/,$pieces1[0]);
	@pieces3=split(',',$pieces1[1]);
	@pieces=(@pieces2,@pieces3);
	#Remove duplicates
	my @unique = ();
   my %Seen   = ();
   foreach my $elem ( @pieces ){
   	next if $Seen{ $elem }++;
      push @unique, $elem;
   }
   @pieces=@unique;
	#print join(" ",@pieces)."\n";
	#Add composite definitions to the $systemString
	foreach $piece (@pieces){
		$found_part=0;
		foreach $parton (@partons){
			@part=split(/=/,$parton);
			if ($part[0] eq $piece){
				$systemString=$systemString.$part[1]."\{";
				$found_part=1;
			}
		}
	}
	
	#Add removals
	my $whichRemove=-1;
	for (my $m=0;$m<=$#removes;$m++){
	  if($removesNumber[$m]==$l+1||$removesNumber[$m]==-1){$whichRemove=$m;}
	}
	if($whichRemove>=0){$systemString=$systemString.$removes[$whichRemove];}
	$systemString=$systemString."\{";
	
	#Add { for 2*x etc..
	if ($systemString =~ /\*x/){$systemString=$systemString."\{";}									
	#Finish $systemString			
	#$systemString=$systemString."\{\\8a";  #Old system used tmp/menup.ch
	$systemString=$systemString."[[\{\\8a";  #New: uses results/list_prc.txt.
	#print "$systemString\n";
	
	#Run CH
	if (`ls tmp/`){system("rm tmp/*");}
	#$systemString = "./calchep -blind \"$systemString\"";
	#$systemString = "$working_dir/calchep -blind \"$systemString\"";
	$systemString = "$CH_PATH/bin/s_calchep -blind \"$systemString\"";
	#print "$systemString\n";
	$result=system($systemString);
	#print "$result\n";
	if($result!=0){
		print "CalcHEP was unable to generate the subprocesses for $process.\n";
		print "Exiting...\n\n";
		exit();
	}
	
	#Extract subprocesses
	#open(MDL_FILE,'tmp/menup.ch'); #Old system used tmp/menup.ch
	open(MDL_FILE, 'results/list_prc.txt');
	LINE: while (my $line = <MDL_FILE>){
		#while ($line =~ /\|([^\|]+->[^\|]+)\|/){ #Old system used tmp/menup.ch
		#	my $sub = $1; #Old system used tmp/menup.ch
			my $sub = $line;
			$sub =~ s/\s//g;
			push(@subprocesses,$sub);
			push(@subproc_which_proc,$l);
			push(@subproc_dir,"");
			push(@subproc_in_lib,0);
			if($whichRemove>=0){push(@subremoves,$removes[$whichRemove]);}
			else {push(@subremoves,"");}
		#	$line =~ s/\|[^\|]+->[^\|]+\|//; #Old system used tmp/menup.ch
	  	#} #Old system used tmp/menup.ch
	}
	close(MDL_FILE);
	print_index(0);print_symbolic();
}
#exit(0);
print_numerical();
#for (my $j=0;$j<=$#cut_Number;$j++){
#	print "$cut_Number[$j]\n";
#}
#print "\n";
#for (my $j=0;$j<=$#reg_Number;$j++){
#	print "$reg_Number[$j]\n";
#}
#print "\n";
#for (my $j=0;$j<=$#alphaNumber;$j++){
#	print "$alphaNumber[$j]\n";
#}
#print "\n";
#for (my $j=0;$j<=$#dist_Number;$j++){
#	print "$dist_Number[$j]\n";
#}

#exit(0);
####################################################
#              Determine subprocesses.             #
#Run calchep with the full process                 #
#Extract the subprocesses from tmp/menup.ch        #
####################################################
#                    1->n                          #
####################################################
print_index(0);print_symbolic();
#foreach $process (@decays){
for (my $l=0;$l<=$#decays;$l++){
	my $process = $decays[$l];
	#Run Process
	$systemString = "";
	for (my $j=1;$j<$model_num;$j++){$systemString=$systemString."[";}
	$systemString=$systemString."\{\{$process\{";
	
	#Partons
	@pieces1=split(/->/,$process);
	@pieces2=split(/,/,$pieces1[0]);
	@pieces3=split(',',$pieces1[1]);
	@pieces=(@pieces2,@pieces3);
	#Remove duplicates
	my @unique = ();
   my %Seen   = ();
   foreach my $elem ( @pieces ){
   	next if $Seen{ $elem }++;
      push @unique, $elem;
   }
   @pieces=@unique;
   #print join(" ",@pieces)."\n";
	#Add composite definitions to the $systemString
	foreach $piece (@pieces){
		$found_part=0;
		foreach $parton (@partons){
			@part=split(/=/,$parton);
			if ($part[0] eq $piece){
				$systemString=$systemString.$part[1]."\{";
				$found_part=1;
			}
		}
	}
	#Finish $systemString
	if ($systemString =~ /\*x/){$systemString=$systemString."\{";}												
	#$systemString=$systemString."\{\\8a";  #Old system used tmp/menup.ch
	$systemString=$systemString."\{[[\{\\8a";  #New: uses results/list_prc.txt.
	#print "$systemString\n";
	
	#Run CH
	if (`ls tmp/`){system("rm tmp/*");}
	#$systemString = "$working_dir/calchep -blind \"$systemString\"";
	$systemString = "$CH_PATH/bin/s_calchep -blind \"$systemString\"";
	#print "$systemString\n";
	$result=system($systemString);
	#print "$result\n";
	if($result!=0){
		print "CalcHEP was unable to generate the subprocesses for $process.\n";
		print "Exiting...\n\n";
		exit();
	}
	
	#Extract subprocesses
	#open(MDL_FILE,'tmp/menup.ch');
	open(MDL_FILE, 'results/list_prc.txt');
	LINE: while (my $line = <MDL_FILE>){
		#while ($line =~ /\|([^\|]+->[^\|]+)\|/){
		#	my $sub = $1;
			my $sub = $line;
			$sub =~ s/\s//g;
			push(@decay_subprocesses,$sub);
			push(@decay_subproc_which_decay,$l);
			push(@decay_subproc_dir,"");
			push(@decay_subproc_in_lib,0);
			push(@decay_subremoves,"");
		#	$line =~ s/\|[^\|]+->[^\|]+\|//;
	  	#}
	}
	close(MDL_FILE);
	print_index(0);print_symbolic();
}


####################################################
#              Determine subprocesses.             #
#Run calchep with the full process                 #
#Extract the subprocesses from tmp/menup.ch        #
####################################################
#                   Combine                        #
####################################################
@all_subprocesses = (@subprocesses,@decay_subprocesses);
@all_subremoves   = (@subremoves,@decay_subremoves);
#@all_subproc_dir = (@subproc_dir,@decay_subproc_dir);
#@all_subproc_in_lib = (@subproc_in_lib,@decay_subproc_in_lib);
#print join("\t",@all_subprocesses)."\n";





####################################################
#           Read the process library               #
####################################################
$next_lib_dir=0;
open(PROC_FILE, "<$working_dir/Processes/$model_dir/processes.txt");
LINE: while($line = <PROC_FILE>){
	if ($line =~ /^#/){next LINE;}
	if ($line =~ /([^:]+):([^:]+):([^:]+)/){
	        $dir=$1;$proc=$2;$rmv=$3;
		#print "$line";
		$dir =~ s/\s//g;
		$proc =~ s/\s//g;
		$rmv =~ s/\s//g;
		#print "$dir  $proc\n";
		push(@lib_dirs,$dir);
		push(@lib_procs,$proc);
		push(@lib_removes,$rmv);
		$dir =~ s/p//g;
		if ($dir > $next_lib_dir){$next_lib_dir=$dir;}
	}
	if ($line =~ /([^:]+):([^:]+)/){
		$dir=$1;$proc=$2;
		#print "$line";
		$dir =~ s/\s//g;
		$proc =~ s/\s//g;
		#print "$dir  $proc\n";
		push(@lib_dirs,$dir);
		push(@lib_procs,$proc);
		push(@lib_removes,"");
		$dir =~ s/p//g;
		if ($dir > $next_lib_dir){$next_lib_dir=$dir;}
	}
}
#print join(" ",@lib_procs)."\n";
close(BATCH_FILE);


####################################################
#     Delete directories not in the library        #
####################################################
@dirs = `ls $working_dir/Processes/$model_dir`;
DIR: foreach $dir (@dirs){
	$dir =~ s/\s//g;
	if ($dir =~ /processes.txt/){next DIR;}
	$in_lib=0;
	foreach $lib_dir (@lib_dirs){
		if ($dir eq $lib_dir){$in_lib=1;}
	}
	if ($in_lib==0){
		system("rm -r $working_dir/Processes/$model_dir/$dir");
	}
}
#print join("",@dirs)."\n";



####################################################
#           Check if the subprocesses              #
#           are already in the library             #
####################################################
SUBPROC: for (my $j=0;$j<=$#subprocesses;$j++){
	for (my $k=0;$k<=$#lib_procs;$k++){
		if ($subprocesses[$j] eq $lib_procs[$k] && $subremoves[$j] eq $lib_removes[$k]){
			#print "$subprocesses[$j] $lib_procs[$k]\n";
			$subproc_dir[$j]=$lib_dirs[$k];
			$subproc_in_lib[$j]=1;
			next SUBPROC;
		}
	}
}
SUBPROC: for (my $j=0;$j<=$#decay_subprocesses;$j++){
	for (my $k=0;$k<=$#lib_procs;$k++){
		if ($decay_subprocesses[$j] eq $lib_procs[$k]){
			$decay_subproc_dir[$j]=$lib_dirs[$k];
			$decay_subproc_in_lib[$j]=1;
			next SUBPROC;
		}
	}
}
for (my $k=0;$k<=$#lib_procs;$k++){
	if ("Widths" eq $lib_procs[$k]){
		$widths_dir=$lib_dirs[$k];
		$widths_in_lib=1;
	}
}

#@all_subproc_dir = (@subproc_dir,@decay_subproc_dir);
#@all_subproc_in_lib = (@subproc_in_lib,@decay_subproc_in_lib);
#print join(",",@all_subproc_in_lib)."\n";
print_index(0);print_symbolic();



####################################################
#                                                  #
#                                                  #
#             Symbolic Sessions                    #
#                                                  #
#                                                  #
####################################################
$symb_begin_time = time();


####################################################
#           Create directories for                 #
#         the processes that are not               #
#            in the library.                       #
####################################################
#$next_lib_dir=$#lib_dirs+1;
$next_lib_dir++;

for (my $j=0;$j<=$#subprocesses;$j++){
	if ($subproc_in_lib[$j]==0){
		#Determine name of new directory
		$subproc_dir[$j]="p".$next_lib_dir;
		$next_lib_dir++;
		
		#Create directories and link calchep to each.
		system("mkdir Processes/$model_dir/$subproc_dir[$j]");
		#system("ln -s $working_dir/calchep Processes/$model_dir/$subproc_dir[$j]/calchep");
		create_calchep("Processes/$model_dir/$subproc_dir[$j]/calchep");
		system("ln -s $CH_PATH/bin Processes/$model_dir/$subproc_dir[$j]/bin");
		system("ln -s $working_dir/models Processes/$model_dir/$subproc_dir[$j]/models");
		system("mkdir Processes/$model_dir/$subproc_dir[$j]/tmp");
		system("mkdir Processes/$model_dir/$subproc_dir[$j]/results");
	}
}

for (my $j=0;$j<=$#decay_subprocesses;$j++){
	if ($decay_subproc_in_lib[$j]==0){
		#Determine name of new directory
		$decay_subproc_dir[$j]="p".$next_lib_dir;
		$next_lib_dir++;
		
		#Create directories and link calchep to each.
		system("mkdir Processes/$model_dir/$decay_subproc_dir[$j]");
		#system("ln -s $working_dir/calchep Processes/$model_dir/$decay_subproc_dir[$j]/calchep");
		create_calchep("Processes/$model_dir/$decay_subproc_dir[$j]/calchep");
		system("ln -s $CH_PATH/bin Processes/$model_dir/$decay_subproc_dir[$j]/bin");
		system("ln -s $working_dir/models Processes/$model_dir/$decay_subproc_dir[$j]/models");
		system("mkdir Processes/$model_dir/$decay_subproc_dir[$j]/tmp");
		system("mkdir Processes/$model_dir/$decay_subproc_dir[$j]/results");
	}
}

if ($widths_in_lib==0){
	#Determine name of new directory
	$widths_dir="w";
	
	#Create directories and link calchep to each.
	system("mkdir Processes/$model_dir/$widths_dir");
	#system("ln -s $working_dir/calchep Processes/$model_dir/$widths_dir/calchep");
	create_calchep("Processes/$model_dir/$widths_dir/calchep");
	system("ln -s $CH_PATH/bin Processes/$model_dir/$widths_dir/bin");
	system("ln -s $working_dir/models Processes/$model_dir/$widths_dir/models");
	system("mkdir Processes/$model_dir/$widths_dir/tmp");
	system("mkdir Processes/$model_dir/$widths_dir/results");
}

@all_subproc_dir = (@subproc_dir,@decay_subproc_dir);
@all_subproc_in_lib = (@subproc_in_lib,@decay_subproc_in_lib);
#print join(",",@all_subproc_in_lib)."\n";
print_index(0);print_symbolic();


####################################################
#      Create symbolic job scripts for             #
#         the processes that are not               #
#            in the library.                       #
####################################################
for (my $j=0;$j<=$#all_subprocesses;$j++){
	if ($all_subproc_in_lib[$j]==0){
		open(JOB_FILE,">Processes/$model_dir/$all_subproc_dir[$j]/job_script")
			or die("Couldn't open Processes/$model_dir/$all_subproc_dir[$j]/jobscript.");
		print JOB_FILE "#!/bin/bash\n";
		my $job_name = $all_subprocesses[$j];
		$job_name =~ s/'//g;#Remove '
		if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info($job_name,"job.o");}
		elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info($job_name,"job.o");}
		print JOB_FILE "cd $working_dir/Processes/$model_dir/$all_subproc_dir[$j]\n";
	
		#Create CH blind string	
		$systemString = "";
		for (my $k=1;$k<$model_num;$k++){$systemString=$systemString."[";}
		if ($gauge =~ /[Uu]nitary/){$systemString=$systemString."\{[\{]";}
		else {$systemString=$systemString."\{";}
		$systemString = $systemString."\{$all_subprocesses[$j]\{";
		$systemString = $systemString."$all_subremoves[$j]\{[\{[[[\{";
		$systemString = "./calchep -blind \"$systemString\"";
		if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
		else {
			print JOB_FILE	"nice -n $nice_level $systemString &> job.o &\n";
			#print JOB_FILE	"nice -n $nice_level $systemString 1> job.o 2> job.e &\n";
			print JOB_FILE "echo \$!\n";
		}
		close(JOB_FILE);
		system("chmod u+x Processes/$model_dir/$all_subproc_dir[$j]/job_script");
	}
}
#exit(0);
if ($widths_in_lib==0){
	open(JOB_FILE,">Processes/$model_dir/$widths_dir/job_script")
		or die("Couldn't open Processes/$model_dir/$widths_dir/jobscript.");
	print JOB_FILE "#!/bin/bash\n";
	if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info("Widths","job.o");}
	elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info("Widths","job.o");}

	print JOB_FILE "cd $working_dir/Processes/$model_dir/$widths_dir\n";

	#Create CH blind string	
	$systemString = "";
	for (my $k=1;$k<$model_num;$k++){$systemString=$systemString."[";}
	if ($gauge =~ /[Uu]nitary/){$systemString=$systemString."\{[\{]";}
	else {$systemString=$systemString."\{";}
	$systemString = $systemString."\{allDec!->2*x\{\{\{\{[\{[[[\{";
	$systemString = "./calchep -blind \"$systemString\"";
	if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
	else {
		print JOB_FILE	"nice -n $nice_level $systemString &> job.o &\n";
		#print JOB_FILE	"nice -n $nice_level $systemString 1> job.o 2> job.e &\n";
		print JOB_FILE "echo \$!\n";
	}
	close(JOB_FILE);
	system("chmod u+x Processes/$model_dir/$widths_dir/job_script");
}

#print num_not_in_lib();
#exit();


####################################################
#             Run symbolic jobs                    #
#              Monitor progress                    #
####################################################
#Run all jobs
$cpus_in_use=0;
@begin_times=();
@end_times=();
$widths_begin_time=0;
$widths_end_time=0;
@pids=();
$widths_pid=0;
foreach $subprocess (@all_subprocesses){
	push(@begin_times,0);
	push(@end_times,0);
	push(@pids,0);
}
while (num_not_in_lib()>0){
	#Check to see how many jobs are finished.
	for (my $j=0;$j<=$#all_subprocesses;$j++){
		if($end_times[$j]==0&&$begin_times[$j]!=0){
			if(-e "Processes/$model_dir/$all_subproc_dir[$j]/job.o") {
				open(OUT_FILE,"Processes/$model_dir/$all_subproc_dir[$j]/job.o")
					or die("Could not open Processes/$model_dir/$all_subproc_dir[$j]/job.o");
				LINE: while ($line = <OUT_FILE>){
				  if($line =~ /n_calchep is created/){
	   				$jobs_finished++;
						$cpus_in_use--;
						$end_times[$j]=time();
						push(@lib_dirs,$all_subproc_dir[$j]);
						push(@lib_procs,$all_subprocesses[$j]);
					        push(@lib_removes,$all_subremoves[$j]);
						$all_subproc_in_lib[$j]=1;
						print_library($all_subproc_dir[$j],$all_subprocesses[$j],$all_subremoves[$j]);
						#print "Eureka!\n";
					}
					elsif($line =~ /[Ee]rror/){
	   				$jobs_finished++;
						$cpus_in_use--;
						$end_times[$j]="Error";
						#print "Error!\n";
						print_symbolic(0);
						print "Error in symbolic session for $all_subprocesses[$j]\n";
						print "Exiting...\n\n";
						exit();
						next LINE;
					}
				}
				close(OUT_FILE);
			}
		}
	}
	#Now the widths
	if($widths_end_time==0&&$widths_begin_time!=0&&$widths_in_lib==0){
			if(-e "Processes/$model_dir/$widths_dir/job.o") {
				open(OUT_FILE,"Processes/$model_dir/$widths_dir/job.o")
					or die("Could not open Processes/$model_dir/$widths_dir/job.o");
				LINE: while ($line = <OUT_FILE>){
				  if($line =~ /n_calchep is created/){
	   				$jobs_finished++;
						$cpus_in_use--;
						$widths_end_time=time();
						push(@lib_dirs,$widths_dir);
						push(@lib_procs,"Widths");
					        push(@lib_removes,"");
						$widths_in_lib=1;
						print_library($widths_dir,"Widths","");
						#print "Eureka!\n";
					}
					elsif($line =~ /[Ee]rror/){
	   				$jobs_finished++;
						$cpus_in_use--;
						$widths_end_time="Error";
						#print "Error!\n";
						print_symbolic(0);
						print "Error in symbolic session for $widths\n";
						print "Exiting...\n\n";
						exit();
					}
				}
				close(OUT_FILE);
			}
		}
	
	#Start new jobs if cpus are available.
	if($cpus_in_use<$max_cpus){
		for (my $j=0;$j<=$#all_subprocesses;$j++){
			if ($begin_times[$j]==0&&$cpus_in_use<$max_cpus&&$all_subproc_in_lib[$j]==0){
				chdir("Processes/$model_dir/$all_subproc_dir[$j]/");
				if($par_meth =~ /[Pp][Bb][Ss]/){
					$pids[$j]=0;
					while($pids[$j]==0){
						sleep 0.1;
						$pids[$j]=`qsub job_script`;
						$pids[$j] =~ s/([^\.]+)\..*/$1/;
					}
				}
				elsif($par_meth =~ /[Ll][Ss][Ff]/){
					$pids[$j]=0;
					#while($pids[$j]==0){
						#sleep 0.1;
						$pids[$j]=`bsub < job_script`;
						$pids[$j] =~ s/\s//g;
					        #print "pids[$j]=$pids[$j]\n";
					#}
				}
				else {
					$pids[$j]=`./job_script`;
					$pids[$j] =~ s/\s//g;
				}
				chdir("$working_dir");
				$begin_times[$j]=time();
				$cpus_in_use++;
			}
		}
		#Now the widths
		if ($cpus_in_use<$max_cpus&&$widths_begin_time==0&&$cpus_in_use<$max_cpus&&$widths_in_lib==0){
			chdir("Processes/$model_dir/$widths_dir/");
			if($par_meth =~ /[Pp][Bb][Ss]/){
				$widths_pid=0;
				while($widths_pid==0){
					sleep 0.1;
					$widths_pid=`qsub job_script`;
					$widths_pid =~ s/([^\.]+)\..*/$1/;
				}
			}
			elsif($par_meth =~ /[Ll][Ss][Ff]/){
				$widths_pid=0;
				#while($widths_pid==0){
					#sleep 0.1;
					$widths_pid=`bsub < job_script`;
					$widths_pid =~ s/\s//g;
				        #print "widths_pid=$widths_pid\n";
				#}
			}
			else {
				$widths_pid=`./job_script`;
				$widths_pid =~ s/\s//g;
			}
			chdir("$working_dir");
			$widths_begin_time=time();
			$cpus_in_use++;
		}
	}

	sleep $sleep_time;
	
#print num_not_in_lib()."\n";
print_index(0);print_symbolic(0);
}
$symb_end_time=time();
print_index(0);print_symbolic(0);





####################################################
#                                                  #
#                                                  #
#             Numerical Sessions                   #
#                                                  #
#                                                  #
####################################################
$cs_begin_time = time();
####################################################
#Create an array with all the steps in it.         #
####################################################
@step = ();
for (my $j=0;$j<=$#run_param;$j++){
	if ($#step<0){
		for (my $k=0;$k<$run_n[$j];$k++){
			@tmp = ();
			push(@tmp,$k);
			push(@step,[@tmp]);
		}
	}
	else {
		@step_tmp = @step;
		@step = ();
		for (my $k=0;$k<$run_n[$j];$k++){
			for (my $l=0;$l<=$#step_tmp;$l++){
				@tmp = @{$step_tmp[$l]};
				push(@tmp,$k);
				push(@step,[@tmp]);
			}
		}
	}
}
#for (my $j=0;$j<=$#step;$j++){
#	@step_tmp = @{$step[$j]};
#	print "@step_tmp\n";
#}


##############################################################
#Create the directories and job scripts for the subprocesses.#
##############################################################
for (my $k=0;$k<=$#subprocesses;$k++){
	my $subprocess = $subprocesses[$k];
	my $dir_name = "$working_dir/Processes/$model_dir/$subproc_dir[$k]";
	#print $dir_name;
	chdir("$dir_name/results/");
	opendir(DIR,".");
	my @sos = grep(/\.so/,readdir(DIR));#`ls *.so`;
	closedir(DIR);
	opendir(DIR,".");
	my @as = grep(/\.a/,readdir(DIR));#`ls *.a`;
	closedir(DIR);
	chdir("$dir_name");
	if ($#step<0){
		chdir($dir_name);
		if (-d "single"){system("rm -r single");}
		system("mkdir single");
		chdir("single");
		#Link the executables
		system("ln -s $dir_name/results/n_calchep n_calchep");
		foreach $so (@sos){
			system("ln -s $dir_name/results/$so $so");
		}
		foreach $a (@as){
			system("ln -s $dir_name/results/$a $a");
		}
		system("ln -s $dir_name/results/extern.h extern.h");
		system("ln -s $dir_name/results/EXTLIB EXTLIB");
		#Create and update session.dat
		system("./n_calchep -blind \'\\8a\'");
		update_session("$dir_name/single",$k,-1);
		
		#Create job script
		open(JOB_FILE,">job_script")
			or die("Couldn't open $dir_name/single/jobscript.");
		print JOB_FILE "#!/bin/bash\n";
		my $job_name = $subprocess;
		$job_name =~ s/'//g;#'
		if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info($job_name,"cs.o");}
		elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info($job_name,"cs.o");}
		print JOB_FILE "cd $dir_name/single/\n";
		$systemString = "$CH_PATH/bin/run_vegas";
		if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
		elsif ($par_meth =~ /this/ || $par_meth =~ /local/){
			print JOB_FILE	"nice -n $nice_level $systemString &> cs.o &\n";
			#print JOB_FILE	"nice -n $nice_level $systemString 1> cs.o 2> cs.e &";
			print JOB_FILE "echo \$!\n";
		}
		close(JOB_FILE);
		system("chmod u+x job_script");
		#print ".";
	}
	else {
		for (my $j=0;$j<=$#step;$j++){
			my @step_tmp = @{$step[$j]};
			my $subdir_name = "";
			for (my $l=0;$l<=$#run_param;$l++){
				$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
					$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
			}
			#print "\t$subdir_name";
			chdir($dir_name);
			if (-d $subdir_name){system("rm -r $subdir_name");}
			system("mkdir $subdir_name");
			chdir($subdir_name);
			#Link the executables
			system("ln -s $dir_name/results/n_calchep n_calchep");
			foreach $so (@sos){
				system("ln -s $dir_name/results/$so $so");
			}
			foreach $a (@as){
				system("ln -s $dir_name/results/$a $a");
			}
			system("ln -s $dir_name/results/extern.h extern.h");
			system("ln -s $dir_name/results/EXTLIB EXTLIB");
			#Create and update session.dat
			system("./n_calchep -blind \'\\8a\'");
			update_session("$dir_name/$subdir_name",$k,$j);

			#Create job script
			open(JOB_FILE,">job_script")
			or die("Couldn't open $dir_name/$subdir_name/jobscript.");
			print JOB_FILE "#!/bin/bash\n";
			my $job_name = $subprocess;
			$job_name =~ s/'//g;#'
			if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info($job_name,"cs.o");}
			elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info($job_name,"cs.o");}
			print JOB_FILE "cd $dir_name/$subdir_name/\n";
			for (my $l=0;$l<=$#run_param;$l++){
				printf JOB_FILE "$CH_PATH/bin/set_param %s %s\n", $run_param[$l], 
					$run_begin[$l]+$run_step[$l]*$step_tmp[$l];
			}
			$systemString = "$CH_PATH/bin/run_vegas";
			if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
			elsif ($par_meth =~ /this/ || $par_meth =~ /local/){
				print JOB_FILE	"nice -n $nice_level $systemString &> cs.o &\n";
				#print JOB_FILE	"nice -n $nice_level $systemString 1> cs.o 2> cs.e &";
				print JOB_FILE "echo \$!\n";
			}
			close(JOB_FILE);
			system("chmod u+x job_script");
			chdir("$dir_name/");
			#print ".";
		}
	}
	#print "\n\n";
}
#print "Done Testing.\n";
#exit();


########################################################
#                                                      #
#          Estimate the cross sections                 #
#                                                      #
########################################################


#########################
#Monitor the progress   #
#Start jobs as necessary#
#########################
@procs_finished=();
$runs_finished=0;
$cpus_in_use=0;
@begin_times=();
@end_times=();
@nevents=();
$jobs_finished=0;
@pids=();
push(@final_cs,0);
###############################
#If a single run is requested.#
###############################
if ($#step<0){
	foreach $subprocess (@all_subprocesses){
		push(@begin_times,0);
		push(@end_times,0);
		push(@pids,0);
		push(@nevents,0);
		push(@cs,0);
	}
	while ($jobs_finished<$#subprocesses+1){
		#Check to see how many jobs are finished.
		for (my $j=0;$j<=$#subprocesses;$j++){
			if($end_times[$j]==0&&$begin_times[$j]!=0){
				$dir_name = "$working_dir/Processes/$model_dir/$subproc_dir[$j]/single";
				if(-e "$dir_name/cs.o") {
					open(OUT_FILE,"$dir_name/cs.o")
						or die("Could not open $dir_name/cs.o");
					while ($line = <OUT_FILE>){
						if($line =~ /^([0-9]+\.[0-9]+E[\+-][0-9]+)\s*$/){
	   					$cs[$j]=$1;
							$jobs_finished++;
							$cpus_in_use--;
							$end_times[$j]=time();
							$line =~ s/\s//g;
							#printf "%f\n",1000*$cs[$j];
							#print "Eureka!\n";
						}
						elsif($line =~ /[Ee]rror/){
	   					$jobs_finished++;
							$cpus_in_use--;
							$end_times[$j]="Error";
							#print "Error! in $subprocesses[$j]\n";
							print_numerical(0);
							print "Error in calculation of cross section for $subprocesses[$j]\n";
							print "Exiting...\n\n";
							exit();
						}
					}
					close(OUT_FILE);
				}
			}
		}
		
		#Start new jobs if cpus are available.
		if($cpus_in_use<$max_cpus){
			for (my $j=0;$j<=$#subprocesses;$j++){
				if ($begin_times[$j]==0&&$cpus_in_use<$max_cpus){
					$dir_name = "$working_dir/Processes/$model_dir/$subproc_dir[$j]/single";
					chdir($dir_name);
					if($par_meth =~ /[Pp][Bb][Ss]/){
						$pids[$j]=0;
						while($pids[$j]==0){
							sleep 0.1;
							$pids[$j]=`qsub job_script`;
							$pids[$j] =~ s/([^\.]+)\..*/$1/;
						}
					}
					elsif($par_meth =~ /[Ll][Ss][Ff]/){
						$pids[$j]=0;
						#while($pids[$j]==0){
							#sleep 0.1;
							$pids[$j]=`bsub < job_script`;
							$pids[$j] =~ s/\s//g;
						        #print "pids[$j]=$pids[$j]\n";
						#}
					}
					elsif($par_meth =~ /this/ || $par_meth =~ /local/){
						#print "$pids[$j]\n";
						$pids[$j]=`./job_script`;
						#print "$pids[$j]\n";
					}
					chdir($working_dir);
					$begin_times[$j]=time();
					$cpus_in_use++;
				}
			}
		}
		
	
	print_index(1);print_numerical(0);
	sleep $sleep_time;
	}
$runs_finished=1;
combine_distributions(0);
}
#################################
#If multiple runs are requested.#
#################################
else {
	my @begin_tmp=();
	my @end_tmp=();
	my @cs_tmp=();
	my @pids_tmp=();
	my @nevents_tmp=();
	for (my $k=0;$k<=step;$k++){
		push(@begin_tmp,0);
		push(@end_tmp,0);
		push(@cs_tmp,0);
		push(@cs_tot,0);
		push(@final_cs,0);
		push(@pids_tmp,0);
		push(@nevents_tmp,0);
		push(@procs_finished,0);
	}
	foreach $subprocess (@all_subprocesses){
		push(@begin_times,[@begin_tmp]);
		push(@end_times,[@end_tmp]);
		push(@cs,[@cs_tmp]);
		push(@pids,[@pids_tmp]);
		push(@nevents,[@nevents_tmp]);
	}
	while ($runs_finished<$#step+1){
		#Check to see how many jobs are finished.
		for (my $k=0;$k<=$#step;$k++){
				@step_tmp = @{$step[$k]};
				$subdir_name = "";
				for (my $l=0;$l<=$#run_param;$l++){
					$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
						$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
				}		
			for (my $j=0;$j<=$#subprocesses;$j++){
				if($end_times[$j][$k]==0&&$begin_times[$j][$k]!=0){
					$dir_name = "$working_dir/Processes/$model_dir/$subproc_dir[$j]/$subdir_name";
						if(-e "$dir_name/cs.o") {
						open(OUT_FILE,"$dir_name/cs.o")
							or die("Could not open $dir_name/cs.o");
						while ($line = <OUT_FILE>){
						  if($line =~ /^([0-9\.E\+-\s]*)$/){
	   						$cs[$j][$k]=$1;
								$procs_finished[$k]++;
			   				$cpus_in_use--;
								$end_times[$j][$k]=time();
								$line =~ s/\s//g;
								if ($procs_finished[$k]>$#subprocesses){
			   					combine_distributions($k);
			   					$procs_finished[$k]=0;
			   					$runs_finished++;
			   					for(my $l=0;$l<=$#subprocesses;$l++){
			   						$cs_tot[$k]=$cs_tot[$k]+$cs[$l][$k];
			   					}
			   					print_index(1);print_numerical(0);
			   				}
								#print "Eureka!\n";
							}
							elsif($line =~ /[Ee]rror/){
			   				$procs_finished[$k]++;
								if ($procs_finished[$k]>$#all_subprocesses){
			   					$procs_finished[$k]=0;
			   					$runs_finished++;
			   				}
								$cpus_in_use--;
								$end_times[$j][$k]="Error";
								#print "Error! in $subprocesses[$j]\n";
								print_numerical(0);
								print "Error in calculation of cross section for $subprocesses[$j]\n\tfor run $subdir_name.\n";
								print "Exiting...\n\n";
								exit();
							}
						}
						close(OUT_FILE);
					}
				}
			}
		}
		
		
		#Start new jobs if cpus are available.
		if($cpus_in_use<$max_cpus){
			for (my $k=0;$k<=$#step;$k++){
				@step_tmp = @{$step[$k]};
				$subdir_name = "";
				for (my $l=0;$l<=$#run_param;$l++){
					$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
						$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
				}		
				for (my $j=0;$j<=$#subprocesses;$j++){
					if ($begin_times[$j][$k]==0&&$cpus_in_use<$max_cpus){
						$dir_name = "$working_dir/Processes/$model_dir/$subproc_dir[$j]/$subdir_name";
						chdir($dir_name);
						if($par_meth =~ /[Pp][Bb][Ss]/){
							$pids[$j][$k]=0;
							while($pids[$j][$k]==0){
								sleep 0.1;
								$pids[$j][$k]=`qsub job_script`;
								$pids[$j][$k] =~ s/([^\.]+)\..*/$1/;
							}
						}
						elsif($par_meth =~ /[Ll][Ss][Ff]/){
							$pids[$j][$k]=0;
							#while($pids[$j][$k]==0){
								#sleep 0.1;
								$pids[$j][$k]=`bsub < job_script`;
								$pids[$j][$k] =~ s/\s//g;
							        #print "pids[$j][$k]=$pids[$j][$k]\n";
							#}
						}
						elsif($par_meth =~ /this/ || $par_meth =~ /local/){
							$pids[$j][$k] =`./job_script`;
						}
						chdir($working_dir);
						$begin_times[$j][$k]=time();
						$cpus_in_use++;
					}
				}
			}
		}
		
	print_index(1);print_numerical(0);
	sleep $sleep_time;
	}	
}
$cs_end_time = time();
print_index(1);print_numerical(0);
#exit();
if($n_events==0){
	print_index(1.5);
	print_numerical(0.5);
	if($cleanup =~ /[Tt]rue/ || $cleanup =~ /[Yy]es/){
		system("rm $working_dir/Events/tmp/*");
	}
	exit();
}


########################################################
#                                                      #
#               Generate Events                        #
#                                                      #
########################################################
$events_begin_time=time();
@nevents=();
@nevents_final=();
if ($#step<0){
	foreach $subprocess (@all_subprocesses){
		push(@nevents,0);
	}
	$nevents_final[0]=0;
}
else {
	my @nevents_tmp=();
	for (my $k=0;$k<=step;$k++){
		push(@nevents_tmp,0);
		push(@nevents_final,0);
	}
	foreach $subprocess (@all_subprocesses){
		push(@nevents,[@nevents_tmp]);
	}
}		
########################################################
#    Update the job scripts for the subprocesses       #
########################################################
for (my $k=0;$k<=$#subprocesses;$k++){
	my $dir_name = "$working_dir/Processes/$model_dir/$subproc_dir[$k]";
	if ($#step<0){
		chdir("$dir_name/single");
		#Create job script
		open(JOB_FILE,">job_script")
			or die("Couldn't open $dir_name/single/jobscript.");
		print JOB_FILE "#!/bin/bash\n";
		my $job_name = $subprocesses[$k];
		$job_name =~ s/'//g;#'
		if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info($job_name,"job.o");}
		elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info($job_name,"job.o");}
		print JOB_FILE "cd $dir_name/single/\n";
		print JOB_FILE "./n_calchep -blind \"[[[[[[[[\{\{0\{[[\{0\{\\8a\"\n";
		my $total_cs=0;
		for (my $l=0;$l<=$#subprocesses;$l++){$total_cs = $total_cs + $cs[$l];}
		$nevents[$k] = int(1.1*$n_events*$cs[$k]/$total_cs);
		my $systemString = sprintf ("$CH_PATH/bin/subproc_cycle 1E+50 %d",$nevents[$k]);
		if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
		elsif ($par_meth =~ /this/ || $par_meth =~ /local/){
			print JOB_FILE	"nice -n $nice_level $systemString &> job.o &\n";
			#print JOB_FILE	"nice -n $nice_level $systemString 1> job.o 2> job.e &";
			print JOB_FILE "echo \$!\n";
		}
		close(JOB_FILE);
		system("chmod u+x job_script");
	}
	else {
		for (my $j=0;$j<=$#step;$j++){
			my @step_tmp = @{$step[$j]};
			my $subdir_name = "";
			for (my $l=0;$l<=$#run_param;$l++){
				$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
					$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
			}
			#print "\t$subdir_name";
			chdir("$dir_name/$subdir_name");
			#Create job script
			open(JOB_FILE,">job_script")
			or die("Couldn't open $dir_name/$subdir_name/jobscript.");
			print JOB_FILE "#!/bin/bash\n";
			my $job_name = $subprocesses[$k];
			$job_name =~ s/'//g;#'
			if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info($job_name,"job.o");}
			elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info($job_name,"job.o");}
			print JOB_FILE "cd $dir_name/$subdir_name/\n";
			print JOB_FILE "./n_calchep -blind \"[[[[[[[[\{\{0\{[[\{0\{\\8a\"\n";
			#for (my $l=0;$l<=$#run_param;$l++){
			#	printf JOB_FILE "$CH_PATH/bin/set_param %s %s\n", $run_param[$l], 
			#		$run_begin[$l]+$run_step[$l]*$step_tmp[$l];
			#}
			my $total_cs=0;
			for (my $l=0;$l<=$#subprocesses;$l++){$total_cs = $total_cs + $cs[$l][$j];}
			$nevents[$k][$j] = int(1.1*$n_events*$cs[$k][$j]/$total_cs);
			my $systemString = sprintf ("$CH_PATH/bin/subproc_cycle 1E+50 %d",$nevents[$k][$j]);
			if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
			elsif ($par_meth =~ /this/ || $par_meth =~ /local/){
				print JOB_FILE	"nice -n $nice_level $systemString &> job.o &\n";
				#print JOB_FILE	"nice -n $nice_level $systemString 1> job.o 2> job.e &";
				print JOB_FILE "echo \$!\n";
			}
			close(JOB_FILE);
			system("chmod u+x job_script");
		}
	}
}

########################################################
#Create the directories and job scripts for the decays.#
########################################################
for (my $k=0;$k<=$#decay_subprocesses;$k++){
	$subprocess = $decay_subprocesses[$k];
	$dir_name = "$working_dir/Processes/$model_dir/$decay_subproc_dir[$k]";
	#print $dir_name;
	chdir("$dir_name/results/");
	opendir(DIR,".");
	my @sos = grep(/\.so/,readdir(DIR));#`ls *.so`;
	closedir(DIR);
	opendir(DIR,".");
	my @as = grep(/\.a/,readdir(DIR));#`ls *.a`;
	close(DIR);
	chdir("$dir_name");
	if ($#step<0){
		chdir($dir_name);
		if (-d "single"){system("rm -r single");}
		system("mkdir single");
		chdir("single");
		#Link the executables
		system("ln -s $dir_name/results/n_calchep n_calchep");
		foreach $so (@sos){
			system("ln -s $dir_name/results/$so $so");
		}
		foreach $a (@as){
			system("ln -s $dir_name/results/$a $a");
		}
		system("ln -s $dir_name/results/extern.h extern.h");
		system("ln -s $dir_name/results/EXTLIB EXTLIB");
		#Create and update session.dat
		system("./n_calchep -blind \'\\8a\'");
		#system("./n_calchep -blind \'[[[[[[[[{[{\\8e0{[{5{[{\\8e0{}[{{\\8e0{\\8a\'");
		update_decay_session("$dir_name/single",$k);

		#Create job script
		open(JOB_FILE,">job_script")
			or die("Couldn't open $dir_name/single/jobscript.");
		print JOB_FILE "#!/bin/bash\n";
		my $job_name = $subprocess;
		$job_name =~ s/'//g;#'
		if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info($job_name,"job.o");}
		elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info($job_name,"job.o");}
		print JOB_FILE "cd $dir_name/single/\n";
		$nevents[$#subprocesses+$k+1] = int(5.1*$n_events);
		my $systemString = sprintf ("$CH_PATH/bin/subproc_cycle %d",$nevents[$#subprocesses+$k+1]);
		if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
		elsif ($par_meth =~ /this/ || $par_meth =~ /local/){
			print JOB_FILE	"nice -n $nice_level $systemString &> job.o &\n";
			#print JOB_FILE	"nice -n $nice_level $systemString 1> job.o 2> job.e &";
			print JOB_FILE "echo \$!\n";
		}
		close(JOB_FILE);
		system("chmod u+x job_script");
		#print ".";
	}
	else {
		for (my $j=0;$j<=$#step;$j++){
			@step_tmp = @{$step[$j]};
			$subdir_name = "";
			for (my $l=0;$l<=$#run_param;$l++){
				$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
					$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
			}
			#print "\t$subdir_name";
			chdir($dir_name);
			if (-d $subdir_name){system("rm -r $subdir_name");}
			system("mkdir $subdir_name");
			chdir($subdir_name);
			#Link the executables
			system("ln -s $dir_name/results/n_calchep n_calchep");
			foreach $so (@sos){
				system("ln -s $dir_name/results/$so $so");
			}
			foreach $a (@as){
				system("ln -s $dir_name/results/$a $a");
			}
			system("ln -s $dir_name/results/extern.h extern.h");
			system("ln -s $dir_name/results/EXTLIB EXTLIB");
			#Create and update session.dat
			system("./n_calchep -blind \'\\8a\'");
			#system("./n_calchep -blind \'[[[[[[[[[{{10000{\\8a\'");
			update_decay_session("$dir_name/$subdir_name",$k);
	
			#Create job script
			open(JOB_FILE,">job_script")
			or die("Couldn't open $dir_name/$subdir_name/jobscript.");
			print JOB_FILE "#!/bin/bash\n";
			my $job_name = $subprocess;
			$job_name =~ s/'//g;#'
			if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info($job_name,"job.o");}
			elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info($job_name,"job.o");}
			print JOB_FILE "cd $dir_name/$subdir_name/\n";
			for (my $l=0;$l<=$#run_param;$l++){
				printf JOB_FILE "$CH_PATH/bin/set_param %s %s\n", $run_param[$l], 
					$run_begin[$l]+$run_step[$l]*$step_tmp[$l];
			}
			$nevents[$#subprocesses+$k+1][$j] = int(5.1*$n_events);
			my $systemString = sprintf ("$CH_PATH/bin/subproc_cycle %d",$nevents[$#subprocesses+$k+1][$j]);
			if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
			elsif ($par_meth =~ /this/ || $par_meth =~ /local/){
				print JOB_FILE	"nice -n $nice_level $systemString &> job.o &\n";
				#print JOB_FILE	"nice -n $nice_level $systemString 1> job.o 2> job.e &";
				print JOB_FILE "echo \$!\n";
			}
			close(JOB_FILE);
			system("chmod u+x job_script");
			chdir("$dir_name/");
			#print ".";
		}
	}
	#print "\n\n";
}

########################################################
#Create the directories and job scripts for the widths.#
########################################################
$subprocess = "Widths";
$dir_name = "$working_dir/Processes/$model_dir/$widths_dir";
#print $dir_name;
chdir("$dir_name/results/");
opendir(DIR,".");
my @sos = grep(/\.so/,readdir(DIR));#`ls *.so`;
closedir(DIR);
opendir(DIR,".");
my @as = grep(/\.a/,readdir(DIR));#`ls *.a`;
close(DIR);
chdir("$dir_name");
if ($#step<0){
	chdir($dir_name);
	if (-d "single"){system("rm -r single");}
	system("mkdir single");
	chdir("single");
	#Link the executables
	system("ln -s $dir_name/results/n_calchep n_calchep");
	foreach $so (@sos){
		system("ln -s $dir_name/results/$so $so");
	}
	foreach $a (@as){
		system("ln -s $dir_name/results/$a $a");
	}
	system("ln -s $dir_name/results/extern.h extern.h");
	system("ln -s $dir_name/results/EXTLIB EXTLIB");
	#Create and update session.dat
	system("./n_calchep -blind \'\\8a\'");
	#system("./n_calchep -blind \'[[[[[[[[{[{\\8e0{[{5{[{\\8e0{}[{{\\8e0{\\8a\'");
	update_decay_session("$dir_name/single",-1);
		#Create job script
	open(JOB_FILE,">job_script")
		or die("Couldn't open $dir_name/single/jobscript.");
	print JOB_FILE "#!/bin/bash\n";
	my $job_name = $subprocess;
	$job_name =~ s/'//g;#'
	if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info($job_name,"job.o");}
	elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info($job_name,"job.o");}
	print JOB_FILE "cd $dir_name/single/\n";
	my $systemString = sprintf ("./n_calchep -blind \"[[[[[[[[[[\{[[[[[[\{\\8a\"");
	if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
	elsif ($par_meth =~ /this/ || $par_meth =~ /local/){
		print JOB_FILE	"nice -n $nice_level $systemString &> job.o &\n";
		#print JOB_FILE	"nice -n $nice_level $systemString 1> job.o 2> job.e &";
		print JOB_FILE "echo \$!\n";
	}
	close(JOB_FILE);
	system("chmod u+x job_script");
	#print ".";
}
else {
	for (my $j=0;$j<=$#step;$j++){
		@step_tmp = @{$step[$j]};
		$subdir_name = "";
		for (my $l=0;$l<=$#run_param;$l++){
			$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
				$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
		}
		#print "\t$subdir_name";
		chdir($dir_name);
		if (-d $subdir_name){system("rm -r $subdir_name");}
		system("mkdir $subdir_name");
		chdir($subdir_name);
		#Link the executables
		system("ln -s $dir_name/results/n_calchep n_calchep");
		foreach $so (@sos){
			system("ln -s $dir_name/results/$so $so");
		}
		foreach $a (@as){
			system("ln -s $dir_name/results/$a $a");
		}
		system("ln -s $dir_name/results/extern.h extern.h");
		system("ln -s $dir_name/results/EXTLIB EXTLIB");
		#Create and update session.dat
		system("./n_calchep -blind \'\\8a\'");
		#system("./n_calchep -blind \'[[[[[[[[[{{10000{\\8a\'");
		update_decay_session("$dir_name/$subdir_name",-1);

		#Create job script
		open(JOB_FILE,">job_script")
		or die("Couldn't open $dir_name/$subdir_name/jobscript.");
		print JOB_FILE "#!/bin/bash\n";
		my $job_name = "Widths";
		$job_name =~ s/'//g;#'
		if($par_meth=~/[Pp][Bb][Ss]/){write_PBS_info($job_name,"job.o");}
		elsif($par_meth=~/[Ll][Ss][Ff]/){write_LSF_info($job_name,"job.o");}
		print JOB_FILE "cd $dir_name/$subdir_name/\n";
		for (my $l=0;$l<=$#run_param;$l++){
			printf JOB_FILE "$CH_PATH/bin/set_param %s %s\n", $run_param[$l], 
				$run_begin[$l]+$run_step[$l]*$step_tmp[$l];
		}
		my $systemString = sprintf ("./n_calchep -blind \"[[[[[[[[[[\{[[[[[[\{\\8a\"");
		if ($par_meth =~ /[Pp][Bb][Ss]/ || $par_meth =~ /[Ll][Ss][Ff]/){print JOB_FILE "$systemString\n";}
		elsif ($par_meth =~ /this/ || $par_meth =~ /local/){
			print JOB_FILE	"nice -n $nice_level $systemString &> job.o &\n";
			#print JOB_FILE	"nice -n $nice_level $systemString 1> job.o 2> job.e &";
			print JOB_FILE "echo \$!\n";
		}
		close(JOB_FILE);
		system("chmod u+x job_script");
		chdir("$dir_name/");
		#print ".";
	}
}
#print "\n\n";




#########################
#Monitor the progress   #
#Start jobs as necessary#
#########################
@procs_finished=();
$runs_finished=0;
$cpus_in_use=0;
@begin_times=();
@end_times=();
$widths_begin_time=0;
$widths_end_time=0;
@pids=();
$widths_pid=0;
#@nevents=();
@nevents_finished=();
$jobs_finished=0;
###############################
#If a single run is requested.#
###############################
if ($#step<0){
	push(@event_filenames,"");
	push(@dist_filenames,"");
	foreach $subprocess (@all_subprocesses){
		push(@begin_times,0);
		push(@end_times,0);
		push(@pids,0);
		#push(@nevents,0);
		push(@nevents_finished,0);
	}
	while ($jobs_finished<$#all_subprocesses+2){
		#Check to see how many jobs are finished.
		for (my $j=0;$j<=$#all_subprocesses;$j++){
			if($end_times[$j]==0&&$begin_times[$j]!=0){
				$dir_name = "$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single";
				if(-e "$dir_name/events_1.txt"){
					$nevents_finished[$j]=`wc -l $dir_name/events_1.txt`;
					$nevents_finished[$j] =~ s/([0-9]*).*/$1/;
					$nevents_finished[$j] = int($nevents_finished[$j])-11;
					#print "$nevents_finished[$j]:\n";
				}
				if(-e "$dir_name/job.o") {
					open(OUT_FILE,"$dir_name/job.o")
						or die("Could not open $dir_name/job.o");
					while ($line = <OUT_FILE>){
						if ($line =~ /#Subprocess[^\)]*\)\s*Cross section\s*=\s*([^,]*),\s*([0-9]*)\s*events/) {
							$cs[$j]=$1;
							$nevents_finished[$j]=$2;
							$cs[$j]=~ s/\s//g;
							$jobs_finished++;
							$cpus_in_use--;
							$end_times[$j]=time();
							#print "Eureka!\n";
						}
						elsif ($line =~ /#Subprocess[^\)]*\)\s*width\s*=\s*([^B]*)\s*Br\s*=([0-9]*)\s*Nevents\s*=\s*([0-9]*)/){
							$cs[$j]=$1;
							$nevents_finished[$j]=$3;
							$cs[$j]=~ s/\s//g;
							$jobs_finished++;
							$cpus_in_use--;
							$end_times[$j]=time();
							#print "Eureka!\n";
						}
						elsif ($line =~ /width\([^\)]*\)=0$/){
							$jobs_finished++;
							$cpus_in_use--;
							$end_times[$j]=time();
						}
						elsif($line =~ /[Ee]rror/){
	   					$jobs_finished++;
							$cpus_in_use--;
							$end_times[$j]="Error";
							#print "Error! in $all_subprocesses[$j]\n";
							print_numerical(1);
							print "Error in generation of events for $all_subprocesses[$j].\n";
							print "Exiting...\n\n";
							exit();
						}
					}
					close(OUT_FILE);
				}
			}
		}
		#Now the widths
		if($widths_end_time==0&&$widths_begin_time!=0){
			$dir_name = "$working_dir/Processes/$model_dir/$widths_dir/single";
			if(-e "$dir_name/decaySLHA1.txt") {
				$jobs_finished++;
				$cpus_in_use--;
				$widths_end_time=time();
			}
		}
		
		#Start new jobs if cpus are available.
		if($cpus_in_use<$max_cpus){
			for (my $j=0;$j<=$#all_subprocesses;$j++){
				if ($begin_times[$j]==0&&$cpus_in_use<$max_cpus){
					$dir_name = "$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single";
					chdir($dir_name);
					if($par_meth =~ /[Pp][Bb][Ss]/){
						$pids[$j]=0;
						while($pids[$j]==0){
							sleep 0.1;
							$pids[$j]=`qsub job_script`;
							$pids[$j] =~ s/([^\.]+)\..*/$1/;
						}
					}
					elsif($par_meth =~ /[Ll][Ss][Ff]/){
						$pids[$j]=0;
						#while($pids[$j]==0){
							#sleep 0.1;
							$pids[$j]=`bsub < job_script`;
							$pids[$j] =~ s/\s//g;
						        #print "pids[$j]=$pids[$j]\n";
						#}
					}
					elsif($par_meth =~ /this/ || $par_meth =~ /local/){
						$pids[$j]=`./job_script`;
					}
					chdir($working_dir);
					$begin_times[$j]=time();
					$cpus_in_use++;
				}
			}
			#Now the widths
			if ($widths_begin_time==0&&$cpus_in_use<$max_cpus){
				$dir_name = "$working_dir/Processes/$model_dir/$widths_dir/single";
				chdir($dir_name);
				if($par_meth =~ /[Pp][Bb][Ss]/){
					$widths_pid=0;
					while($widths_pid==0){
						sleep 0.1;
						$widths_pid=`qsub job_script`;
						$widths_pid =~ s/([^\.]+)\..*/$1/;
					}
				}
				elsif($par_meth =~ /[Ll][Ss][Ff]/){
					$widths_pid=0;
					#while($widths_pid==0){
						#sleep 0.1;
						$widths_pid=`bsub < job_script`;
						$widths_pid =~ s/\s//g;
					        #print "widths_pid=$widths_pid\n";
					#}
				}
				elsif($par_meth =~ /this/ || $par_meth =~ /local/){
					$widths_pid=`./job_script`;
				}
				chdir($working_dir);
				$widths_begin_time=time();
				$cpus_in_use++;
			}
		}
		
	print_index(2);print_numerical(1);
	sleep $sleep_time;
	}
$runs_finished=1;
combine_distributions(0);
combine_events(0);
}
#################################
#If multiple runs are requested.#
#################################
else {
	my @begin_tmp=();
	my @end_tmp=();
	#my @cs_tmp=();
	my @pids_tmp=();
	#my @nevents_tmp=();
	my @nevents_finished_tmp=();
	@widths_begin_times=();
	@widths_end_times=();
	@widths_pids=();
	for (my $k=0;$k<=step;$k++){
		push(@begin_tmp,0);
		push(@end_tmp,0);
		#push(@cs_tmp,0);
		push(@cs_tot,0);
		push(@pids_tmp,0);
		#push(@nevents_tmp,0);
		push(@nevents_finished_tmp,0);
		push(@event_filenames,"");
		push(@dist_filenames,"");
		push(@procs_finished,0);
		push(@widths_begin_times,0);
		push(@widths_end_times,0);
		push(@widths_pids,0);
	}
	foreach $subprocess (@all_subprocesses){
		push(@begin_times,[@begin_tmp]);
		push(@end_times,[@end_tmp]);
		#push(@cs,[@cs_tmp]);
		push(@pids,[@pids_tmp]);
		#push(@nevents,[@nevents_tmp]);
		push(@nevents_finished,[@nevents_finished_tmp]);
	}
	while ($runs_finished<$#step+1){
		#Check to see how many jobs are finished.
		for (my $k=0;$k<=$#step;$k++){
				@step_tmp = @{$step[$k]};
				$subdir_name = "";
				for (my $l=0;$l<=$#run_param;$l++){
					$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
						$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
				}		
			for (my $j=0;$j<=$#all_subprocesses;$j++){
				if($end_times[$j][$k]==0&&$begin_times[$j][$k]!=0){
					$dir_name = "$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name";
					if(-e "$dir_name/events_1.txt"){
						$nevents_finished[$j][$k] =`wc -l $dir_name/events_1.txt`;
						$nevents_finished[$j][$k] =~ s/([0-9]*).*/$1/;
						$nevents_finished[$j][$k] = int($nevents_finished[$j][$k])-11;
					}
					if(-e "$dir_name/job.o") {
						open(OUT_FILE,"$dir_name/job.o")
							or die("Could not open $dir_name/job.o");
						while ($line = <OUT_FILE>){
						  if ($line =~ /#Subprocess[^\)]*\)\s*Cross section\s*=\s*([^,]*),\s*([0-9]*)\s*events/) {
								$cs[$j][$k]=$1;
								$nevents_finished[$j][$k]=$2;
								$cs[$j][$k]=~ s/\s//g;
						  		for(my $l=0;$l<=$#subprocesses;$l++){
			   					$cs_tot[$k]=$cs_tot[$k]+$cs[$l][$k];
			   				}
						  		$procs_finished[$k]++;
			   				$cpus_in_use--;
								$end_times[$j][$k]=time();
								if ($procs_finished[$k]>$#all_subprocesses+1){
			   					combine_distributions($k);
			   					combine_events($k);
			   					$procs_finished[$k]=0;
			   					$runs_finished++;
			   					print_index(2);print_numerical(1);
			   				}
								#print "Eureka!\n";
							}
						  elsif ($line =~ /#Subprocess[^\)]*\)\s*width\s*=\s*([^B]*)\s*Br\s*=([0-9]*)\s*Nevents\s*=\s*([0-9]*)/){
								$cs[$j][$k]=$1;
								$nevents_finished[$j][$k]=$3;
								$cs[$j][$k]=~ s/\s//g;
						  		$procs_finished[$k]++;
			   				$cpus_in_use--;
								$end_times[$j][$k]=time();
								if ($procs_finished[$k]>$#all_subprocesses+1){
			   					combine_distributions($k);
			   					combine_events($k);
			   					$procs_finished[$k]=0;
			   					$runs_finished++;
			   					print_index(2);print_numerical(1);
			   				}
								#print "Eureka!\n";
							}
							elsif ($line =~ /width\([^\)]*\)=0$/){
								$procs_finished[$k]++;
			   				$cpus_in_use--;
								$end_times[$j][$k]=time();
								if ($procs_finished[$k]>$#all_subprocesses+1){
									combine_distributions($k);
			   					combine_events($k);
			   					$procs_finished[$k]=0;
			   					$runs_finished++;
			   					print_index(2);print_numerical(1);
			   				}
							}
							elsif($line =~ /[Ee]rror/){
			   				$procs_finished[$k]++;
								if ($procs_finished[$k]>$#all_subprocesses+1){
			   					$procs_finished[$k]=0;
			   					$runs_finished++;
			   				}
								$cpus_in_use--;
								$end_times[$j][$k]="Error";
								#print "Error! in $all_subprocesses[$j]\n";
								print_numerical(1);
								print "Error in generation of events for $all_subprocesses[$j]\n\tfor run $dir_name.\n";
								print "Exiting...\n\n";
								exit();
							}
						}
						close(OUT_FILE);
					}
				}
			}
			#Now for the widths
			if($widths_end_times[$k]==0&&$widths_begin_times[$k]!=0){
				$dir_name = "$working_dir/Processes/$model_dir/$widths_dir/$subdir_name";
				if(-e "$dir_name/decaySLHA1.txt") {
					$procs_finished[$k]++;
			   	$cpus_in_use--;
					$widths_end_times[$k]=time();
					if ($procs_finished[$k]>$#all_subprocesses+1){
						combine_distributions($k);
			   		combine_events($k);
			   		$procs_finished[$k]=0;
			   		$runs_finished++;
			   		print_index(2);print_numerical(1);
			   	}
				}
			}
		}
		
		
		#Start new jobs if cpus are available.
		if($cpus_in_use<$max_cpus){
			for (my $k=0;$k<=$#step;$k++){
				@step_tmp = @{$step[$k]};
				$subdir_name = "";
				for (my $l=0;$l<=$#run_param;$l++){
					$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
						$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
				}		
				for (my $j=0;$j<=$#all_subprocesses;$j++){
					if ($begin_times[$j][$k]==0&&$cpus_in_use<$max_cpus){
						$dir_name = "$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name";
						chdir($dir_name);
						if($par_meth =~ /[Pp][Bb][Ss]/){
							$pids[$j][$k]=0;
							while($pids[$j][$k]==0){
								sleep 0.1;
								$pids[$j][$k]=`qsub job_script`;
								$pids[$j][$k] =~ s/([^\.]+)\..*/$1/;
							}
						}
						elsif($par_meth =~ /[Ll][Ss][Ff]/){
							$pids[$j][$k]=0;
							#while($pids[$j][$k]==0){
								#sleep 0.1;
								$pids[$j][$k]=`bsub < job_script`;
								$pids[$j][$k] =~ s/\s//g;
							        #print "pids[$j][$k]=$pids[$j][$k]\n";
							#}
						}
						elsif($par_meth =~ /this/ || $par_meth =~ /local/){
							$pids[$j][$k] =`./job_script`;
						}
						chdir($working_dir);
						$begin_times[$j][$k]=time();
						$cpus_in_use++;
					}
				}
				#Now for the widths
				if ($widths_begin_times[$k]==0&&$cpus_in_use<$max_cpus){
					$dir_name = "$working_dir/Processes/$model_dir/$widths_dir/$subdir_name";
					chdir($dir_name);
					if($par_meth =~ /[Pp][Bb][Ss]/){
						$widths_pids[$k]=0;
						while($widths_pids[$k]==0){
							sleep 0.1;
							$widths_pids[$k]=`qsub job_script`;
							$widths_pids[$k] =~ s/([^\.]+)\..*/$1/;
						}
					}
					elsif($par_meth =~ /[Ll][Ss][Ff]/){
						$widths_pids[$k]=0;
						#while($widths_pids[$k]==0){
							#sleep 0.1;
							$widths_pids[$k]=`bsub < job_script`;
							$widths_pids[$k] =~ s/\s//g;
						        #print "widths_pids[$k]=$widths_pids[$k]\n";
						#}
					}
					elsif($par_meth =~ /this/ || $par_meth =~ /local/){
						$widths_pids[$k] =`./job_script`;
					}
					chdir($working_dir);
					$widths_begin_times[$k]=time();
					$cpus_in_use++;
				}
			}
		}
		
		print_index(2);print_numerical(1);
		sleep $sleep_time;
	}	
}
$events_end_time = time();
print_index(2);print_numerical(1);



#Done!!!
print_index(3);
print_numerical(2);
if($cleanup =~ /[Tt]rue/ || $cleanup =~ /[Yy]es/){
	system("rm $working_dir/Events/tmp/*");
}












####################################################
#                                                  #
#              Functions                           #
#                                                  #
####################################################

####################################################
#            Num of procs not in lib               #
####################################################
sub num_not_in_lib {
	my $result=0;
	for (my $j=0;$j<=$#all_subproc_in_lib;$j++){
		if ($all_subproc_in_lib[$j]==0){$result++;}
	}
	if($widths_in_lib==0){$result++;}
	return $result;
}


####################################################
#            Create calchep file                   #
####################################################
sub create_calchep {
	open(CALCHEP,">$_[0]");
	print CALCHEP ":\nCALCHEP=$CH_PATH\n";
	print CALCHEP <<ENDCH;
export CALCHEP

. \$CALCHEP/FlagsForSh

while :
do 
  \$CALCHEP/bin/s_calchep \$*
  err=\$?
  case \$err in 
     0) exit;; 
    20) ;;
    22)
         \$CALCHEP/bin/s_calchep -blind "[{{0" 
         cd results 
         . ./EXTLIB
         \$CALCHEP/nCompil 1>/dev/null 2>/dev/null; \$CALCHEP/ld_n
         err=\$?
         if(test \$err -eq 0) then
           echo n_calchep is created
         else 
           echo n_calchep is not created. 
         fi 
         break;;
     *) echo CalcHEP has finished with error code \$err
      break 
  esac 
done 	
ENDCH
	close(CALCHEP);
	system("chmod u+x $_[0]");
}

################################################################
#PBS specific job script                                       #
################################################################
sub write_PBS_info { 
  if(length($que)>0){print JOB_FILE "#PBS -q $que\n";}
  
  #Turn walltime into string with minutes.
  my $wall_hrs=int($walltime);
  my $wall_mins=int((60*$walltime)%60);
  my $PBSwalltime=sprintf("%i:%02i:00",$wall_hrs,$wall_mins);

  if($walltime>0&&$memory>0){print JOB_FILE "#PBS -l walltime=$PBSwalltime -l mem=${memory}gb\n";}
  elsif($walltime>0){print JOB_FILE "#PBS -l walltime=$PBSwalltime\n";}
  elsif($memory>0){print JOB_FILE "#PBS -l mem=${memory}gb\n";}
  my $job_name = $_[0];
  $job_name =~ s/'//g;#'
  print JOB_FILE "#PBS -N $_[0]\n";
  print JOB_FILE "#PBS -o $_[1]\n";
  print JOB_FILE "#PBS	-j oe\n";
  #print JOB_FILE "#PBS -e cs.e\n\n";
  if($email =~ /@/){
    print JOB_FILE "#PBS	-m a\n";
    print JOB_FILE "#PBS -M $email\n";
  }
  print JOB_FILE "\n";
}

################################################################
#LSF specific job script                                       #
################################################################
sub write_LSF_info { 
  if(length($que)>0){print JOB_FILE "#BSUB -q $que\n";}
  if($LSFproject ne ""){print JOB_FILE "#BSUB -P $LSFproject\n";}
  
  #Turn walltime into string with minutes.
  my $wall_hrs=int($walltime);
  my $wall_mins=int((60*$walltime)%60);
  my $LSFwalltime=sprintf("%i:%02i",$wall_hrs,$wall_mins);
  if($walltime>0){print JOB_FILE "#BSUB -c $LSFwalltime\n";}

  my $LSFmem=1000*$memory;
  if($memory>0){print JOB_FILE "#BSUB -R \"mem>$LSFmem\"\n";}
  my $job_name = $_[0];
  $job_name =~ s/'//g;#'
  print JOB_FILE "#BSUB -J $_[0]\n";
  print JOB_FILE "#BSUB -o $_[1]\n";
  if($email =~ /@/){print JOB_FILE "#BSUB -u $email\n";}
  print JOB_FILE "\n";
}

################################################################
#Update the session.dat files                                  #
################################################################
sub update_session {
	my $dir_name = $_[0];
	#print "$working_dir/Processes/$dir_name/results/\n";
	#system("pwd");
	#system("./n_calchep -blind \'\\8a\'");
	system("mv $dir_name/session.dat $dir_name/session.dat-old");
	open(SESSION_FILE,"$dir_name/session.dat-old");
	open(NEW_SESSION_FILE, ">$dir_name/session.dat");
	my $init_section=0;
	my $param_section=0;
	my $cuts_section=0;
	my $kinematics_section=0;
	my $reg_section=0;
	my $dists_section=0;
	SESSION_LINE: while (my $line = <SESSION_FILE>){
		if    ($line =~ /#Initial_state/){$init_section=1;}
		elsif ($line =~ /Physical_Parameters/){$param_section=1;$init_section=0;}
		elsif ($line =~ /----/){$param_section=0;}
		elsif ($line =~ /#Kinematical_scheme/){$kinematics_section=1;}
		elsif ($line =~ /#Cuts/){$cuts_section=1;$kinematics_section=0;}
		elsif ($line =~ /#Regularization/){$reg_section=1;}
		elsif ($line =~ /#Distributions/){$dists_section=1;$cuts_section=0;$reg_section=0;$kinematics_section=0;}
		elsif ($line =~ /========/){$dists_section=0;$cuts_section=0;$reg_section=0;}
		
		if ($init_section==1){
			printf NEW_SESSION_FILE "#Initial_state  inP1=%.6E  inP2=%.6E\n",
				$p1,$p2;
			printf NEW_SESSION_FILE " Polarizations= { 0.000000E+00  0.000000E+00 }\n";
			printf NEW_SESSION_FILE "  StrFun1=%s\n", $pdf1_name;
			printf NEW_SESSION_FILE "  StrFun2=%s\n\n", $pdf2_name;
			$init_section=2;
		}
		if ($param_section==1){
			print NEW_SESSION_FILE "#Physical_Parameters \n";
			for(my $j=0;$j<=$#vars_names;$j++){
				printf NEW_SESSION_FILE "%10s = %.15E\n",$vars_names[$j], $vars_values[$j];
			}
			$param_section=2;
		}
		if ($kinematics_section==1){
			#First find out if the user defined kinematics for this process.
			#If not, set kinematics section to 0.
			#Otherwise, print the kinematics.
			my $kin_defined=0;
			for(my $j=0;$j<=$#kinematics;$j++){
				if ($kin_Number[$j]==$subproc_which_proc[$_[1]]||$kin_Number[$j]==-1){
					$kin_defined=1;
				}
			}
			if ($kin_defined==0){$kinematics_section=0;}
			else {
				$kinematics_section=2;
				print NEW_SESSION_FILE "#Kinematical_scheme\n";
				for(my $j=0;$j<=$#kinematics;$j++){
					if ($kin_Number[$j]==$subproc_which_proc[$_[1]]||$kin_Number[$j]==-1){
						my $new_kinematics="";
						my @kin_pieces = split(/->/,$kinematics[$j]);
						if ($kin_pieces[0] eq "12"){$new_kinematics="12 -> ";}
						else {$new_kinematics=renumber_parts($kin_pieces[0],$_[1])." -> ";}
						my @kin2_pieces = split(/,/,$kin_pieces[1]);
						foreach my $kin2_piece (@kin2_pieces){
							$new_kinematics=$new_kinematics.renumber_parts($kin2_piece,$_[1])." , ";
						}
						$new_kinematics = substr($new_kinematics,0,length($new_kinematics)-3);
						print NEW_SESSION_FILE "$new_kinematics\n";
					}
				}
			}
		}
		if ($cuts_section==1){
			print NEW_SESSION_FILE "#Cuts\n";
			print NEW_SESSION_FILE "*** Table ***\n";
			print NEW_SESSION_FILE " Cuts\n";
			print NEW_SESSION_FILE "!|  Parameter  |> Min bound <|> Max bound <|\n";
			for(my $j=0;$j<=$#cut_param;$j++){
				#print "$_[1] : $subproc_which_proc[$_[1]]\n";
				if ($cut_Number[$j]==$subproc_which_proc[$_[1]]||$cut_Number[$j]==-1){
					my @tmp_cut_param=rename_parts($cut_param[$j],$_[1]);
					my $tmp_invert="";
					if($cut_invert[$j] =~ /[Tt][Rr][Uu][Ee]/) {$tmp_invert="!|";}
					else {$tmp_invert=" |";}
					my $tmp_cut_min=update_min_max($cut_min[$j],$_[2]);
					my $tmp_cut_max=update_min_max($cut_max[$j],$_[2]);
					#print "\t$cut_param[$j] -> {".join(",",@tmp_cut_param)."}\n";
					for(my $k=0;$k<=$#tmp_cut_param;$k++){
						printf NEW_SESSION_FILE 
							"%s%-13s|%-13s|%-13s|\n",$tmp_invert,$tmp_cut_param[$k],$tmp_cut_min,$tmp_cut_max;
					}
				}
			}
			$cuts_section=2;
		}
		if ($reg_section==1){
			print NEW_SESSION_FILE "#Regularization\n";
			print NEW_SESSION_FILE "*** Table ***\n";
			print NEW_SESSION_FILE " Regularization\n";
			print NEW_SESSION_FILE " Momentum    |> Mass  <|> Width <| Power|\n";
			for(my $j=0;$j<=$#reg_mom;$j++){
				if ($reg_Number[$j]==$subproc_which_proc[$_[1]]||$reg_Number[$j]==-1){
					printf NEW_SESSION_FILE "%-13s|%-9s|%-9s|%-6s|\n",
						renumber_parts($reg_mom[$j],$_[1]),$reg_mass[$j],$reg_width[$j],$reg_pow[$j];
				}
			}
			$reg_section=2;
		}
		if ($dists_section==1){
			print NEW_SESSION_FILE "#Distributions \n";
			print NEW_SESSION_FILE "*** Table ***\n";
			print NEW_SESSION_FILE "Distributions\n";
			print NEW_SESSION_FILE "Parameter_1|> Min_1  <|> Max_1  <|Parameter_2|> Min_2  <|> Max_2  <|\n";
			for(my $j=0;$j<=$#dist_param;$j++){
				#print "$_[1] : $subproc_which_proc[$_[1]]\n";
				if ($dist_Number[$j]==$subproc_which_proc[$_[1]]||$dist_Number[$j]==-1){
					my @tmp_dist_param = rename_parts($dist_param[$j],$_[1]);
					my $tmp_dist_min=update_min_max($dist_min[$j],$_[2]);
					my $tmp_dist_max=update_min_max($dist_max[$j],$_[2]);
					#print "\t$dist_param[$j] -> {".join(",",@tmp_dist_param)."}\n";
					for ($k=0;$k<=$#tmp_dist_param;$k++){
						printf NEW_SESSION_FILE 
							"%-11s|%-10s|%-10s|%-11s|%-10s|%-10s|\n",$tmp_dist_param[$k],$tmp_dist_min,$tmp_dist_max,"","","";
					}
				}
			}
			$dists_section=2;
		}
		if ($init_section==0&&$param_section==0&&$cuts_section==0&& $reg_section==0 && $kinematics_section==0 && $dists_section==0){
			$line =~ s/#Vegas_calls 10000x5 10000x0/#Vegas_calls ${nCalls1}x${nSess1} ${nCalls2}x${nSess2}/;
			$line =~ s/#Events 1000 100 50 50 ([0-9]+) 2.000000/#Events $subCubes $randSearch $simpSearch $findNewMax $1 $maxN/;
			
			$randTime++;
			my $randSeed = sprintf ("%x",$randTime);
			while (length($randSeed)<12){$randSeed="1".$randSeed;}
			$randSeed=uc($randSeed);
			#print "$randSeed\n";
			$line =~ s/#Random [0-9A-Z]+/#Random $randSeed/;
			
			if ($line =~ /#QCD alphaPDF/){
				my $aScale = "M12";
				for (my $l=0;$l<=$#alphaScale;$l++){
					if ($alphaNumber[$l]==$subproc_which_proc[$_[1]]||$alphaNumber[$l]==-1){$aScale=renumber_parts($alphaScale[$l],$_[1]);}
				}
				$line =sprintf ("#QCD alphaPDF=%i alpha(MZ)=%.5E NF=%i Order=%i MbMb=%.5E Mtp=%.5E Scale= %s\n",
					$alphaPDF,$alphaMZ,$alphaNF,$alphaOrder,$alphaMbMb,$alphaMtp,$aScale);
			}
			print NEW_SESSION_FILE $line;	
		}
	}
	close(SESSION_FILE);
	close(NEW_SESSION_FILE);
	system("cp $dir_name/session.dat $dir_name/session.dat-start");
}


################################################################
#  Renumber cut, distribution, regularization and kinematics   # 
#  according to particle order in current process.             #
################################################################
sub renumber_parts {
	my $new_param_name = "";
	my $proc="";
	my $subproc="";
	if($_[1]<=$#subprocesses){
		$proc=$processes[$subproc_which_proc[$_[1]]];
		$subproc=$subprocesses[$_[1]];
	}
	else{
		$proc=$decays[$decay_subproc_which_decay[$_[1]-$#subprocesses-1]];
		$subproc=$decay_subprocesses[$_[1]-$#subprocesses-1];
	}
	#print "$proc\t$subproc\n";	
	#print "";
	for (my $i=0;$i<length($_[0]);$i++){
		my $cur_num = substr($_[0],$i,1);
		my $part_num=0;
		if ($cur_num =~ /M/){$new_param_name=$new_param_name."M";$part_num=1;}
		#elsif ($cur_num =~ /[a-zA-Z\(\),\/]/){$new_param_name=$new_param_name.$cur_num;$part_num=0;}
		elsif ($cur_num =~ /[^\d]/){$new_param_name=$new_param_name.$cur_num;$part_num=0;}
		elsif ($cur_num =~ /[0-9]/&&$part_num==1){$new_param_name=$new_param_name.$cur_num;}
		elsif ($cur_num =~ /[0-9]/&&$part_num==0) {
			#Determine what particle this is.
			my @pieces1 = split("->",$proc);
			my @pieces = split(",",@pieces1[0]);
			push(@pieces,split(",",@pieces1[1]));
			my $cmpst_tmp=$pieces[$cur_num-1];
			my $cmpst_num_tmp=1;
			my $start=2;if($_[1]>$#subprocesses){$start=1;}
			for (my $j=$start;$j<$cur_num-1;$j++){
				if ($cmpst_tmp eq $pieces[$j]){$cmpst_num_tmp++;}
			}
			#Determine what particles it corresponds with if composite.
			my @partons_tmp=();
			#print "$cmpst_tmp\t";
			for (my $j=0;$j<=$#cmpst_names;$j++){
				if ($cmpst_tmp eq $cmpst_names[$j]){
					@pieces1 = split("=",$partons[$j]);
					@pieces = split(",",$pieces1[1]);
					push(@partons_tmp,@pieces);
				}		
			}
			if ($#partons_tmp<0){push(@partons_tmp,$cmpst_tmp);}
			#print "\t".join(",",@partons_tmp)."\t";
			#Determine the position of the particle in the subprocess.
			my $cur_cmpst_num=1;
			@pieces1 = split("->",$subproc);
			@pieces = split(",",@pieces1[0]);
			push(@pieces,split(",",@pieces1[1]));
			for (my $j=$start;$j<=$#pieces;$j++){
				#print "\n$pieces[$j]\n\t";
				for (my $k=0;$k<=$#partons_tmp;$k++){
					#print "$partons_tmp[$k]\t";
					if ($pieces[$j] eq $partons_tmp[$k]){
				  	        if ($cur_cmpst_num == $cmpst_num_tmp){$new_param_name=$new_param_name.($j+1);$cur_cmpst_num++;}#print "$cur_num -> ".($j+1)."\n";}
						else {$cur_cmpst_num++;}
					}
				}
			}		
			
		}
	}
	#print "$subprocesses[$_[1]]\n";
	#print "\t$_[0] -> $new_param_name\n";
	if (defined $options{r}){return $_[0];}
	else {return $new_param_name;}
}


################################################################
#  Rename cut and distribution names                           # 
#  according to particles in current process.                  #
################################################################
sub rename_parts {
	my @new_names=();
	if (defined $options{n}){
		push(@new_names,renumber_parts($_[0]));
		return @new_names;
	}
	elsif ($_[0] =~ /^U/){#User defined.
		return $_[0];
	}
	
	my @begin = split(/\(/,$_[0]);
	my @end = split(/\)/,$begin[1]);
	my @parts = split(",",$end[0]);
	my @f_pieces = ();
	my %count = ();
	
	#print "";
	for (my $i=0;$i<=$#parts;$i++){
		my @i_pieces = ();
		my $cmpst_tmp=$parts[$i];
		#Determine what particles it corresponds with if composite.
		my @partons_tmp=();
		#print "$cmpst_tmp\t";
		for (my $j=0;$j<=$#cmpst_names;$j++){
			if ($cmpst_tmp eq $cmpst_names[$j]){
				@pieces1 = split("=",$partons[$j]);
				@pieces = split(",",$pieces1[1]);
				push(@partons_tmp,@pieces);
			}		
		}
		if ($#partons_tmp<0){push(@partons_tmp,$cmpst_tmp);}
		#print "\t".join(",",@partons_tmp)."\t";
		
		#Determine the particles in the subprocess.
		@pieces1 = split("->",$subprocesses[$_[1]]);
		@pieces = split(",",@pieces1[1]);
		for (my $j=0;$j<=$#pieces;$j++){
			#Count the number of each.
			#$count{$pieces[$j]}++;
			#print "\n$pieces[$j]\n\t";
			for (my $k=0;$k<=$#partons_tmp;$k++){
				#print "$partons_tmp[$k]\t";
				if ($pieces[$j] eq $partons_tmp[$k]){
					push(@i_pieces,$pieces[$j]);
				}
			}
		}		
		push(@f_pieces,join(",",@i_pieces));
		
	}
	#print "\t".($#f_pieces+1)."\n";
	
	#Count the number of each particle.
	@pieces1 = split("->",$subprocesses[$_[1]]);
	@pieces = split(",",@pieces1[1]);
	for (my $j=0;$j<=$#pieces;$j++){
		$count{$pieces[$j]}++;
	}
				
	#Combine the particles in all nonduplicate ways.
	#1 parameter
	if($#f_pieces==0){
		my @parts1=split(",",$f_pieces[0]);
		for(my $i=0;$i<=$#parts1;$i++){
			my %count_tmp = ();
			$count_tmp{$parts1[$i]}++;
			if($count{$parts1[$i]}>=$count_tmp{$parts1[$i]}){
				push(@new_names,$begin[0]."(".$parts1[$i].")");
			}
		}		
	}
	#2 parameters
	elsif($#f_pieces==1){
		my @parts1=split(",",$f_pieces[0]);
		my @parts2=split(",",$f_pieces[1]);
		for(my $i=0;$i<=$#parts1;$i++){
			for(my $j=0;$j<=$#parts2;$j++){
				my %count_tmp = ();
				$count_tmp{$parts1[$i]}++;
				$count_tmp{$parts2[$j]}++;
				#if(($parts1[$i] ne $parts2[$j]) || $count{$parts1[$i]}){
				if(	$count{$parts1[$i]}>=$count_tmp{$parts1[$i]} && 
						$count{$parts2[$j]}>=$count_tmp{$parts2[$j]} 
						){
					my @tmp_parts=sort($parts1[$i],$parts2[$j]);
					push(@new_names,$begin[0]."(".join(",",@tmp_parts).")");
				}
			}
		}		
	}
	#3 parameters
	elsif($#f_pieces==2){
		my @parts1=split(",",$f_pieces[0]);
		my @parts2=split(",",$f_pieces[1]);
		my @parts3=split(",",$f_pieces[2]);
		for(my $i=0;$i<=$#parts1;$i++){
			for(my $j=0;$j<=$#parts2;$j++){
				for(my $k=0;$k<=$#parts3;$k++){
					my %count_tmp = ();
					$count_tmp{$parts1[$i]}++;
					$count_tmp{$parts2[$j]}++;
					$count_tmp{$parts3[$k]}++;
					#print "$parts1[$i] : $count{$parts1[$i]} : $count_tmp{$parts1[$i]}\n";
					#print "$parts2[$j] : $count{$parts2[$j]} : $count_tmp{$parts2[$j]}\n";
					#print "$parts3[$k] : $count{$parts3[$k]} : $count_tmp{$parts3[$k]}\n";
					#if($parts1[$i] ne $parts2[$j]&& $parts1[$i] ne $parts3[$k]&& $parts2[$j] ne $parts3[$k]){
					if(	$count{$parts1[$i]}>=$count_tmp{$parts1[$i]} && 
							$count{$parts2[$j]}>=$count_tmp{$parts2[$j]} &&
							$count{$parts3[$k]}>=$count_tmp{$parts3[$k]} 
							){
						my @tmp_parts=sort($parts1[$i],$parts2[$j],$parts3[$k]);
						push(@new_names,$begin[0]."(".join(",",@tmp_parts).")");
					}
				}
			}
		}		
	}
	#4 parameters
	elsif($#f_pieces==3){
		my @parts1=split(",",$f_pieces[0]);
		my @parts2=split(",",$f_pieces[1]);
		my @parts3=split(",",$f_pieces[2]);
		my @parts4=split(",",$f_pieces[3]);
		for(my $i=0;$i<=$#parts1;$i++){
			for(my $j=0;$j<=$#parts2;$j++){
				for(my $k=0;$k<=$#parts3;$k++){
					for(my $l=0;$l<=$#parts4;$l++){
						my %count_tmp = ();
						$count_tmp{$parts1[$i]}++;
						$count_tmp{$parts2[$j]}++;
						$count_tmp{$parts3[$k]}++;
						$count_tmp{$parts4[$l]}++;
						#if($parts1[$i] ne $parts2[$j]&& $parts1[$i] ne $parts3[$k]&& $parts1[$i] ne $parts4[$l]&&
						if(	$count{$parts1[$i]}>=$count_tmp{$parts1[$i]} && 
								$count{$parts2[$j]}>=$count_tmp{$parts2[$j]} &&
								$count{$parts3[$k]}>=$count_tmp{$parts3[$k]} &&
								$count{$parts4[$l]}>=$count_tmp{$parts4[$l]} 
								){
							my @tmp_parts=sort($parts1[$i],$parts2[$j],$parts3[$k],$parts4[$l]);
							push(@new_names,$begin[0]."(".join(",",@tmp_parts).")");
						}
					}
				}
			}
		}		
	}
	if($#f_pieces>3){
		print "The number of arguments in $_[0] is more than I can currently handle.\n";
		exit();
	}
	
	#Remove duplicates
	my @unique = ();
   my %Seen   = ();
   foreach my $elem ( @new_names ){
   	next if $Seen{ $elem }++;
   	push @unique, $elem;
   }

	
	#print "\t$_[0] -> {".join(",",@unique)."}\n";
	
	return @unique;
}


################################################################
#  Update cut and distribution min and max                     # 
#  according to parameters being run over.                     #
################################################################
sub update_min_max {
	my $new_value=$_[0];
	#Determine run parameter values.
	my @step_tmp = @{$step[$_[1]]};
	for (my $l=0;$l<=$#run_param;$l++){
		my $run_value = $run_begin[$l]+$run_step[$l]*$step_tmp[$l];
		$new_value =~ s/{$run_param[$l]}/($run_value)/g;
		#printf "%s -> %s\n", $_[0], $new_value; 
	}
	
	return $new_value;
}

################################################################
#Update the decay session.dat files                            #
################################################################
sub update_decay_session {
	my $dir_name = $_[0];
	#print "$working_dir/Processes/$dir_name/results/\n";
	#system("pwd");
	#system("./n_calchep -blind \'[[[[[[[[[{{10000{\\8a\'");
	system("mv $dir_name/session.dat $dir_name/session.dat-old");
	open(SESSION_FILE,"$dir_name/session.dat-old");
	open(NEW_SESSION_FILE, ">$dir_name/session.dat");
	my $param_section=0;
	my $kinematics_section=0;
	SESSION_LINE: while (my $line = <SESSION_FILE>){
		if ($line =~ /Physical_Parameters/){$param_section=1;}
		elsif ($line =~ /----/){$param_section=0;}
		elsif ($line =~ /#Kinematical_scheme/){$kinematics_section=1;}
		elsif ($line =~ /#Cuts/){$kinematics_section=0;}
		
		if ($param_section==1){
			print NEW_SESSION_FILE "#Physical_Parameters \n";
			for(my $j=0;$j<=$#vars_names;$j++){
				printf NEW_SESSION_FILE "%10s = %.15E\n",$vars_names[$j], $vars_values[$j];
			}
			$param_section=2;
		}
		#Kinematics
		if ($kinematics_section==1){
			#First find out if the user defined kinematics for this process.
			#If not, set kinematics section to 0.
			#Otherwise, print the kinematics.
			my $kin_defined=0;
			for(my $j=0;$j<=$#decay_kinematics;$j++){
				if ($decay_kin_Number[$j]==$decay_subproc_which_decay[$_[1]]||$decay_kin_Number[$j]==-1){
					$kin_defined=1;
				}
			}
			if ($kin_defined==0 || $_[1]==-1){$kinematics_section=0;}
			else {
				$kinematics_section=2;
				print NEW_SESSION_FILE "#Kinematical_scheme\n";
				for(my $j=0;$j<=$#decay_kinematics;$j++){
					if ($decay_kin_Number[$j]==$decay_subproc_which_decay[$_[1]]||$decay_kin_Number[$j]==-1){
						my $new_kinematics="";
						my @kin_pieces = split(/->/,$decay_kinematics[$j]);
						if ($kin_pieces[0] eq "1"){$new_kinematics="1 -> ";}
						else {$new_kinematics=renumber_parts($kin_pieces[0],$_[1]+$#subprocesses+1)." -> ";}
						my @kin2_pieces = split(/,/,$kin_pieces[1]);
						foreach my $kin2_piece (@kin2_pieces){
							$new_kinematics=$new_kinematics.renumber_parts($kin2_piece,$_[1]+$#subprocesses+1)." , ";
						}
						$new_kinematics = substr($new_kinematics,0,length($new_kinematics)-3);
						print NEW_SESSION_FILE "$new_kinematics\n";
					}
				}
			}
		}
		#$param_section=0;
		if ($param_section==0 && $kinematics_section==0){
			$line =~ s/#Vegas_calls 10000x5 10000x0/#Vegas_calls ${nCalls1}x${nSess1} ${nCalls2}x${nSess2}/;
			$line =~ s/#Events 1000 100 50 50 ([0-9]+) 2.000000/#Events $subCubes $randSearch $simpSearch $findNewMax $1 $maxN/;
			
			$randTime++;
			my $randSeed = sprintf ("%x",$randTime);
			while (length($randSeed)<12){$randSeed="1".$randSeed;}
			$randSeed=uc($randSeed);
			#print "$randSeed\n";
			$line =~ s/#Random [0-9A-Z]+/#Random $randSeed/;
			
			print NEW_SESSION_FILE $line;
		}
	}
	close(SESSION_FILE);
	close(NEW_SESSION_FILE);
	system("cp $dir_name/session.dat $dir_name/session.dat-start");
	
}



####################################################
#                                                  #
#           Combine Events                         #
#                                                  #
####################################################
sub combine_events {
	my @contents=`ls $working_dir/Events/tmp`;
	if ($#contents>=0){system("rm $working_dir/Events/tmp/*");}
	my $subdir_name = "";
	for (my $j=0;$j<=$#all_subprocesses;$j++){
		my $dir_name="$working_dir/Processes/$model_dir/$all_subproc_dir[$j]";
		$subdir_name="";
		if ($#step<0){$subdir_name="single";}
		else{
			my @step_tmp = @{$step[$_[0]]};
			for (my $l=0;$l<=$#run_param;$l++){
				$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
					$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
				for (my $k=0;$k<=$#vars_names;$k++){
					if ($vars_names[$k] eq $run_param[$l]){$vars_values[$k]=$run_begin[$l]+$run_step[$l]*$step_tmp[$l];}
				}
			}
		}
		$dir_name=$dir_name."/$subdir_name";
		$systemString = "ln -s $dir_name/events_1.txt 	$working_dir/Events/tmp/events_$j.txt";
		system($systemString);
	}
	$systemString = "ln -s $dir_name/../results/qNumbers 	$working_dir/Events/tmp/qNumbers";
	system($systemString);
	#Now for the widths
	my $dir_name="$working_dir/Processes/$model_dir/$widths_dir";
	$subdir_name="";
	if ($#step<0){$subdir_name="single";}
	else{
		my @step_tmp = @{$step[$_[0]]};
		for (my $l=0;$l<=$#run_param;$l++){
			$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
				$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
			for (my $k=0;$k<=$#vars_names;$k++){
				if ($vars_names[$k] eq $run_param[$l]){$vars_values[$k]=$run_begin[$l]+$run_step[$l]*$step_tmp[$l];}
			}
		}
	}
	$dir_name=$dir_name."/$subdir_name";
	$systemString = "ln -s $dir_name/decaySLHA1.txt 	$working_dir/Events/tmp/decaySLHA.txt";
	system($systemString);
	
	#Print the batch file details.
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	if ($fileName eq ""){
		$event_filenames[$_[0]] = sprintf "%4d-%02d-%02d-%s",$year+1900,$mon+1,$mday,$subdir_name;
	}
	else {
		$event_filenames[$_[0]] = sprintf "%s-%s",$fileName,$subdir_name;
	}
	print_run_details($event_filenames[$_[0]]);
	
	#Run event_mixer
	chdir("$working_dir/Events/tmp/");
	system("nice -n $nice_level $CH_PATH/bin/event_mixer $n_events . 1> event_mixer.o 2> event_mixer.e");
	
	#Count the number of lines
	#$nevents_final[$_[0]] =`wc -l $working_dir/Events/tmp/event_mixer.out`;
	#$nevents_final[$_[0]] =~ s/([0-9]*).*/$1/;
	#$nevents_final[$_[0]] = int($nevents_final[$_[0]])-1;
	$nevents_final[$_[0]] = $n_events;
	
	#Read the final cs.
	open(MIXER_FILE,"$working_dir/Events/tmp/event_mixer.o")
		or die("Couldn't open $working_dir/Events/tmp/event_mixer.o.");
	while (my $line = <MIXER_FILE>){
		if($line =~ /total cross section\s*([^\s]*)/){$final_cs[$_[0]]=$1;}
	}
	close(MIXER_FILE);
	
	
	#Add batch details and rename
	#Plain format has been removed from event_mixer.
	#if ($fileFormat =~ /plain/){
	#	my $nt_filename = $event_filenames[$_[0]];
	#	$event_filenames[$_[0]] = sprintf "%s.out",$event_filenames[$_[0]];
	#	system("cat $working_dir/Events/tmp/run_details.txt $working_dir/Events/tmp/event_mixer.out > $working_dir/Events/$event_filenames[$_[0]]");
	#	if (-e "$CH_PATH/bin/nt_maker"){
	#		system("nice -n $nice_level $CH_PATH/bin/nt_maker &> nt_maker.o");
	#		#system ("rm $working_dir/Events/$nt_filename-*.nt");
	#		opendir(DIR,"$working_dir/Events/tmp/");
	#		my @nts = grep(/\.nt/,readdir(DIR));
	#		closedir(DIR);
	#		my $j=0;
	#		foreach $nt (@nts){
	#			$j++;
	#			system("cp $working_dir/Events/tmp/$nt $working_dir/Events/${nt_filename}-$j.nt");
	#		}
	#		
	#	}
	#}
	#else {
	#	$event_filenames[$_[0]] = sprintf "%s.lhe",$event_filenames[$_[0]];
	#	system("cat $working_dir/Events/tmp/run_details.txt $working_dir/Events/tmp/event_mixer.lhe > $working_dir/Events/$event_filenames[$_[0]]");
	#}
	#Only LHE format is now supported.  
	#nt maker now works on LHE format.
	my $nt_filename = $event_filenames[$_[0]];
	if ((-e "$CH_PATH/bin/nt_maker")&&$ntuple =~ /[Tt]rue/){
		system("nice -n $nice_level $CH_PATH/bin/nt_maker $working_dir/Events/tmp/event_mixer.lhe &> nt_maker.o");
		#system ("rm $working_dir/Events/$nt_filename-*.nt");
		opendir(DIR,"$working_dir/Events/tmp/");
		my @nts = grep(/\.nt/,readdir(DIR));
		closedir(DIR);
		my $j=0;
		foreach $nt (@nts){
			$j++;
			system("cp $working_dir/Events/tmp/$nt $working_dir/Events/${nt_filename}-$j.nt");
		}	
	}	
	$event_filenames[$_[0]] = sprintf "%s.lhe",$event_filenames[$_[0]];
#	system("cat $working_dir/Events/tmp/run_details.txt $working_dir/Events/tmp/event_mixer.lhe > $working_dir/Events/$event_filenames[$_[0]]");
	system("mv $working_dir/Events/tmp/event_mixer.lhe  $working_dir/Events/$event_filenames[$_[0]]");
	
	#Cleanup
	if ($cleanup =~ /[Tt]rue/ || $cleanup =~ /[Yy]es/ ) {
		for (my $j=0;$j<=$#all_subprocesses;$j++){
			my $dir_name="$working_dir/Processes/$model_dir/$all_subproc_dir[$j]";
			$subdir_name="";
			if ($#step<0){$subdir_name="single";}
			else{
				my @step_tmp = @{$step[$_[0]]};
				for (my $l=0;$l<=$#run_param;$l++){
					$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
						$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
				}
			}
			$dir_name=$dir_name."/$subdir_name";
			$systemString = "rm $dir_name/events_1.txt";
			if (-e "$dir_name/events_1.txt"){system($systemString);}
			
		}
	}
	
	print_event_library($event_filenames[$_[0]]);
	
	
}


####################################################
#                                                  #
#           Combine Distributions                  #
#                                                  #
####################################################
sub combine_distributions {
	#Make a list of the distribution synonyms
	my @tmp_dist_params=();
	for(my $j=0;$j<=$#dist_param;$j++){
		my @tmp_tmp_dist_params=();
		for(my $k=0;$k<=$#subprocesses;$k++){
			@tmp_tmp_dist_params=(@tmp_tmp_dist_params,rename_parts($dist_param[$j],$k));
		}
		#Remove duplicates
		my @unique = ();
	   my %Seen   = ();
   	foreach my $elem ( @tmp_tmp_dist_params ){
   		next if $Seen{ $elem }++;
   		push @unique, $elem;
   	}
   	#Add unique synonyms to list
   	#print "$dist_param[$j] -> {".join(",",@unique)."}\n";
   	push(@tmp_dist_params,[@unique]);
	}
	#print "Test 1\n";
			
	
	#Link the distribution files
	my $sum_distr_command="nice -n $nice_level $CH_PATH/bin/sum_distr";
	if ($#subprocesses==0){$sum_distr_command="nice -n $nice_level more";}
	my @contents=`ls $working_dir/Events/tmp`;
	if ($#contents>=0){system("rm $working_dir/Events/tmp/*");}
	my $subdir_name = "";
	for (my $j=0;$j<=$#subprocesses;$j++){
		#Determine directory
		my $dir_name="$working_dir/Processes/$model_dir/$all_subproc_dir[$j]";
		$subdir_name="";
		if ($#step<0){$subdir_name="single";}
		else{
			my @step_tmp = @{$step[$_[0]]};
			for (my $l=0;$l<=$#run_param;$l++){
				$subdir_name = sprintf("%s%s%s",$subdir_name, $run_param[$l], 
					$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
				for (my $k=0;$k<=$#vars_names;$k++){
					if ($vars_names[$k] eq $run_param[$l]){$vars_values[$k]=$run_begin[$l]+$run_step[$l]*$step_tmp[$l];}
				}
			}
		}
		$dir_name=$dir_name."/$subdir_name";
		#rename distributions according to synonyms
		open(DIST_FILE,"$dir_name/distr_1");
		open(NEW_DIST_FILE, ">$dir_name/new_distr_1");
		DIST_LINE: while (my $line = <DIST_FILE>){
			#print $line;
			for(my $k=0;$k<=$#dist_param;$k++){
				my @tmp_tmp_dist_params = @{$tmp_dist_params[$k]};
				#print "$dist_param[$k] -> {".join(",",@tmp_tmp_dist_params)."}\n";
				foreach my $param (@tmp_tmp_dist_params){
					$param =~ s/\(/\\(/g;
					$param =~ s/\)/\\)/g;
					#print "$param -> $dist_param[$k]\n";
					$line =~ s/$param/$dist_param[$k]/g;
				}
			}
			print NEW_DIST_FILE $line;
		}
		close(DIST_FILE);
		close(NEW_DIST_FILE);
		#Link distribution
		$systemString = "ln -s $dir_name/new_distr_1 	$working_dir/Events/tmp/distr_$j";
		$sum_distr_command = $sum_distr_command." distr_$j";
		system($systemString);
		#print "Test $j\n";
	}
	
	#Run sum_distr
	chdir("$working_dir/Events/tmp/");
	$sum_distr_command = $sum_distr_command." > distr";
	#print "$sum_distr_command\n";
	system($sum_distr_command);
	
	#Choose an appropriate name and copy to Events directory
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	if ($fileName eq ""){
		$dist_filenames[$_[0]] = sprintf "%4d-%02d-%02d-%s.distr",$year+1900,$mon+1,$mday,$subdir_name;
	}
	else {
		$dist_filenames[$_[0]] = sprintf "%s-%s.distr",$fileName,$subdir_name;
	}
	$system_string="cp distr $working_dir/Events/$dist_filenames[$_[0]]";
	system($system_string);
	
	
	#Plot using gnuplot.
	open(GP_INST,">gnuplot_instructions");
	print GP_INST "set term png transparent medium xffffff x000000 x000000 xadd8e6 xadd8e6 x000000\n";
	print GP_INST "set key off\n";
	print GP_INST "set mxtics\n";
	print GP_INST "set mytics\n";
	print GP_INST "set ylabel 'sigma/bin (fb)'\n\n";
	#Parameter values
	for (my $j=0;$j<=$#vars_names;$j++){
		print GP_INST "$vars_names[$j]=$vars_values[$j]\n";
	}
	print GP_INST "\n"; 
	my $i=0;
	my @tmp_plot_filenames=();
	my $copy_string="";
	for(my $j=0;$j<=$#dist_param;$j++){
		my @tmp_dist_param = rename_parts($dist_param[$j],$_[1]);
		for ($k=0;$k<=$#tmp_dist_param;$k++){
			$i++;
			$system_string="$CH_PATH/bin/show_distr -blind  '\\06".$dist_param[$j]."{{\\06 ".$dist_n_bins[$j]." {{ [[[{0'   distr";
			#print "$system_string\n";
			system($system_string);
			my $min = $dist_min[$j];
			my $max = $dist_max[$j];
			if ($#step>-1){
				$min = update_min_max($dist_min[$j],$_[0]);
				$max = update_min_max($dist_max[$j],$_[0]);
			}
			print GP_INST "\nset title '$dist_title[$j]'\n";
			print GP_INST "set xlabel '$dist_x_title[$j]'\n";
			print GP_INST "set output 'distr_$i.png'\n";
			print GP_INST "min = $min\n";
			print GP_INST "max = $max\n";
			print GP_INST "bin_size = (max-min)/$dist_n_bins[$j].0\n";
			print GP_INST "plot[min:max] ".
				"'plot_$i.txt' using (min+\$0*bin_size+(bin_size/2)):(1000*(\$1-\$2)*bin_size) with histeps,".
				"'plot_$i.txt' using (min+\$0*bin_size+(bin_size/2)):(1000*(\$1+\$2)*bin_size) with histeps,".
				"'plot_$i.txt' using (min+\$0*bin_size+(bin_size/2)):(1000*\$1*bin_size) with histeps\n";
			#Create filename.
			my $tmp_plot_filename="";
			if ($fileName eq ""){
				$tmp_plot_filename = sprintf "%4d-%02d-%02d-%s_$i.png",$year+1900,$mon+1,$mday,$subdir_name;
			}
			else {
				$tmp_plot_filename = sprintf "%s-%s_$i.png",$fileName,$subdir_name;
			}
			push(@tmp_plot_filenames,$tmp_plot_filename);
			$copy_string=$copy_string."cp distr_$i.png $working_dir/Events/$tmp_plot_filename;";
		}
	}
	close(GP_INST);
	$system_string="gnuplot gnuplot_instructions";
	system($system_string);
	system($copy_string);
	@plot_filenames[$_[0]]=[@tmp_plot_filenames];
	
	
	
	
}



####################################################
#            Print Events Library                  #
####################################################
sub print_init_event_library {
	open(LIB_FILE, ">$working_dir/Events/events.txt");
	print LIB_FILE "################################\n";
	print LIB_FILE "#        Events Library        #\n";
	print LIB_FILE "#    Automatically generated   #\n";
	print LIB_FILE "#     Do not edit this file    #\n";
	print LIB_FILE "################################\n";
	close(LIB_FILE);
}
sub print_event_library {
	open(LIB_FILE, ">>$working_dir/Events/events.txt");
	print LIB_FILE "$_[0]\n";
	close(LIB_FILE);
	

	#List contents of Events directory.
	opendir(DIR,"$working_dir/Events/");
	my @lhes = grep(/\.lhe/,readdir(DIR));
	closedir(DIR);
	opendir(DIR,"$working_dir/Events/");
	my @outs = grep(/\.out/,readdir(DIR));
	closedir(DIR);
	my @event_lib_filenames = (@lhes,@outs);
	@event_lib_filenames = sort @event_lib_filenames;
	opendir(DIR,"$working_dir/Events/");
	my @nts = grep(/\.nt/,readdir(DIR));
	closedir(DIR);
	opendir(DIR,"$working_dir/Events/");
	my @distrs = grep(/\.distr/,readdir(DIR));
	closedir(DIR);
	my %event_lib_dates = ();
	foreach $event_lib_filename (@event_lib_filenames){
		$event_lib_dates{$event_lib_filename}=ctime(stat("$working_dir/Events/$event_lib_filename")->mtime);
	}
	
	
	
	
						
	#my @event_lib_filenames=();
	#open(LIB_FILE, "$working_dir/Events/events.txt");
	#LINE: while($line = <LIB_FILE>){
	#	if ($line =~ /^#/){next LINE;}
	#	$line =~ s/\s//g;
	#	push (@event_lib_filenames,$line);
	#}
	#close(LIB_FILE);
	#@event_lib_filenames=reverse(@event_lib_filenames);
	
	#Write library.html
	open(HTML_FILE, ">$html_dir/events.html");
	print HTML_FILE "<html>\n";
   print HTML_FILE "<head>\n";
   print HTML_FILE "\t<title>CalcHEP Events Library</title>\n";
   print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
   print HTML_FILE "\t <link rel='stylesheet' href='style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
   print HTML_FILE "<body>\n";
   ############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
	
   print HTML_FILE "<div id='main'>\n";
   print HTML_FILE "\t<h1>CalcHEP Events Library</h1>\n";
   print HTML_FILE "\t<table>\n";
   print HTML_FILE "\t\t<tr><th>Date</th><th>LHE</th><th>plain</th><th>Ntuple</th></tr>\n";
   #foreach $filename_tmp (@event_lib_filenames){
   #	print HTML_FILE "\t\t<tr><td><a href='$working_dir/Events/$filename_tmp'>$filename_tmp</a></td></tr>\n";
	#}
	foreach $event_lib_filename (@event_lib_filenames){
		if ($event_lib_filename =~ /\.lhe$/){
			print HTML_FILE "\t\t<tr><td>$event_lib_dates{$event_lib_filename}</td><td><a href='$working_dir/Events/$event_lib_filename'>$event_lib_filename</a></td></tr>\n";
		}
		elsif ($event_lib_filename =~ /\.out$/){
			my @out_nts = ();
			my $short_filename = $event_lib_filename;
			$short_filename =~ s/([^\.]+).out/$1/;
			foreach $nt (@nts){
				my $short_nt = $nt;
				$short_nt =~ s/([^\.]+)-[0-9]+.nt/$1/;
				if ($short_nt eq $short_filename){ push(@out_nts,$nt);}
			}
			print HTML_FILE "\t\t<tr><td>$event_lib_dates{$event_lib_filename}</td><td></td><td><a href='$working_dir/Events/$event_lib_filename'>$event_lib_filename</a></td><td>";
			@out_nts = reverse @out_nts;
			foreach $out_nt (@out_nts){
				print HTML_FILE "<a href='$working_dir/Events/$out_nt'>$out_nt</a><br>";
			}
			print HTML_FILE "</td></tr>\n";
		}
	}
	
	print HTML_FILE "\t</table>\n";
	print HTML_FILE "</div></body></html>\n";
	close(HTML_FILE);
}


####################################################
#              Printing routines                   #
####################################################

####################################################
#              Print style file                    #
####################################################
sub print_style_file {
	open(CSS_FILE,">$html_dir/style.css");
	print CSS_FILE <<CSS;
#links {
	width: 11em;
	position: fixed;
	top: 5em;
}
#main {
	width: 45em;
	position: absolute;
	left: 13em;
	text-align: center;
}
#help_main {
	width: 31em;
	position: absolute;
	left: 20em;
	text-align: center;
}
table {
	padding-top: 0.5em;
	padding-bottom: 0.5em;
	margin: auto;
}
td {
	vertical-align: top;
	padding-left: 5px;
	padding-right: 5px;
}
a {
	text-decoration: none;
	color: #556f9f;
}
a:hover {
	text-decoration: underline;
}
ul {
	margin: 0px;
	margin-left: 1em;
	padding: 0px;
}
li {
	list-style-type: none;
}
p {
	text-align: justify;
}
CSS
	close(CSS_FILE);
}


####################################################
#              Print batch details.                #
####################################################
sub print_request {
	open(HTML_FILE, ">$html_dir/request.html");
	#Head
	print HTML_FILE "<html>\n";
	print HTML_FILE "<head>\n";
	#print HTML_FILE "\t<title>CalcHEP Batch Request Details</title>\n";
	print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
	print HTML_FILE "\t <link rel='stylesheet' href='style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
	#Body
	print HTML_FILE "<body>\n";
	############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
	
	print HTML_FILE "<div id='main'>\n";
	#print HTML_FILE "\t<h1>Batch Request Details</h1>\n";
	print HTML_FILE "\t<table>\n";
	print HTML_FILE "\t\t<tr><td>\n";
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='2'>Model</th></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>Model:</td><td>$model_name</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>Changed:</td><td>$model_changed</td></tr>\n";
	#print HTML_FILE "\t\t\t<tr></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>Gauge:</td><td>$gauge</td></tr>\n";
	print HTML_FILE "\t\t</table>\n";
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th>Processes</th></tr>\n";
	foreach $process (@processes){
		print HTML_FILE "\t\t\t<tr><td>$process</td></tr>\n";
	};
	foreach $decay (@decays){
		print HTML_FILE "\t\t\t<tr><td>$decay</td></tr>\n";
	};
	print HTML_FILE "\t\t</table>\n";
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th>Composites</th></tr>\n";
	foreach $parton (@partons){
		print HTML_FILE "\t\t\t<tr><td>$parton</td></tr>\n";
	};
	print HTML_FILE "\t\t</table>\n";
	print HTML_FILE "\t\t</td><td>\n";
	
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='2'>Parameters</th></tr>\n";
	for (my $j=0;$j<=$#vars_names;$j++){
		print HTML_FILE "\t\t\t<tr><td>$vars_names[$j]:</td><td>$vars_values[$j]</td></tr>\n";
	}
	print HTML_FILE "\t\t</table>\n";
	print HTML_FILE "\t\t</td></tr><tr><td>\n";
	
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='2'>PDFs</th></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>pdf<sub>1</sub>:</td><td>$pdf1</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>pdf<sub>2</sub>:</td><td>$pdf2</td></tr>\n";
	print HTML_FILE "\t\t</table>\n";
	print HTML_FILE "\t\t</td><td>\n";
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='2'>Momenta</th></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>p<sub>1</sub>=</td><td>$p1</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>p<sub>2</sub>=</td><td>$p2</td></tr>\n";
	print HTML_FILE "\t\t</table>\n";
	print HTML_FILE "\t\t</td></tr><tr><td>\n";
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='3'>Cuts</th></tr>\n";
	print HTML_FILE "\t\t\t<tr><th>Param</th><th>Min</th><th>Max</th></tr>\n";
	for (my $j=0;$j<=$#cut_param;$j++){
		print HTML_FILE "\t\t\t<tr><td>$cut_param[$j]</td><td>$cut_min[$j]</td><td>$cut_max[$j]</td></tr>\n";
	}
	print HTML_FILE "\t\t</table>\n";
	
	print HTML_FILE "\t\t</td><td>\n";
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='4'>Regularizations</th></tr>\n";
	print HTML_FILE "\t\t\t<tr><th>Mom</th><th>Mass</th><th>Width</th><th>Power</th></tr>\n";
	for (my $j=0;$j<=$#reg_mom;$j++){
		print HTML_FILE "\t\t\t<tr><td>$reg_mom[$j]</td><td>$reg_mass[$j]</td><td>$reg_width[$j]</td><td>$reg_pow[$j]</td></tr>\n";
	}
	print HTML_FILE "\t\t</table>\n";
	
	print HTML_FILE "\t\t</td></tr><tr><td>\n";
	
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='4'>Runs</th></tr>\n";
	print HTML_FILE "\t\t\t<tr><td colspan='4'>N events (per step): $n_events</td</tr>\n";
	print HTML_FILE "\t\t\t<tr><th>Param</th><th>Begin</th><th>Step</th><th>N</th></tr>\n";
	for (my $j=0;$j<=$#run_param;$j++){
		print HTML_FILE "\t\t\t<tr><td>$run_param[$j]</td><td>$run_begin[$j]</td><td>$run_step[$j]</td><td>$run_n[$j]</td></tr>\n";
	}
	print HTML_FILE "\t\t</table>\n";
	
	print HTML_FILE "\t\t</td><td>\n";
	
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='2'>Parallelization Details</th></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>Parallelization:</td><td>$par_meth</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>Que:</td><td>$que</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>Walltime:</td><td>${walltime}hrs</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>Memory:</td><td>${memory}gb</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>email:</td><td>$email</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>Max cpus:</td><td>$max_cpus</td></tr>\n";
	print HTML_FILE "\t\t</table>\n";

	print HTML_FILE "\t\t</td></tr><tr><td>\n";

	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='2'>Vegas</th></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>n_Sess1</td><td>$nSess1</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>n_Calls1</td><td>$nCalls1</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>n_Sess2</td><td>$nSess2</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>n_Calls2</td><td>$nCalls2</td></tr>\n";
	print HTML_FILE "\t\t</table>\n";
	
	print HTML_FILE "\t\t</td><td>\n";
	
	print HTML_FILE "\t\t<table>\n";
	print HTML_FILE "\t\t\t<tr><th colspan='2'>Event Generator</th></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>sub-cubes</td><td>$subCubes</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>random search</td><td>$randSearch</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>simplex search</td><td>$simpSearch</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>max*N</td><td>$maxN</td></tr>\n";
	print HTML_FILE "\t\t\t<tr><td>find new MAX</td><td>$findNewMax</td></tr>\n";
	print HTML_FILE "\t\t</table>\n";
	
	
	print HTML_FILE "\t\t</td></tr>\n";
	print HTML_FILE "\t</table>\n";
	
	print HTML_FILE "</div>\n";
	print HTML_FILE "</body>\n";
	print HTML_FILE "</html>\n";
	close(HTML_FILE);
}

####################################################
#      Print run details for event file.           #
#      Plain format was removed as of 0.63.        #
####################################################
sub print_run_details {
	open(TXT_FILE, ">$working_dir/Events/tmp/run_details.txt");
	print TXT_FILE	"\n";
	print TXT_FILE "<calchep-batch>\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Model Info                 #\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "Model:     $model_name\n";
	print TXT_FILE "#$model_url\n";
	print TXT_FILE "Gauge:     $gauge\n\n";
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Processes                  #\n";
	print TXT_FILE "#########################################\n";
	foreach $process (@processes){
		print TXT_FILE "Process   :    $process\n";
	};
	foreach $decay (@decays){
		print TXT_FILE "Decay     :     $decay\n";
	};
	foreach $parton (@partons){
		print TXT_FILE "Composite :    $parton\n";
	};
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            PDF's                      #\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "pdf1 :       $pdf1\n";
	print TXT_FILE "pdf2 :       $pdf2\n\n";
	if($pdf1  =~ /[Ii][Ss][Rr].*[Bb]eam/ || $pdf2  =~ /[Ii][Ss][Rr].*[Bb]eam/){
		print TXT_FILE	"Bunch x+y sizes (nm) : $bunch_size\n";
		print TXT_FILE "Bunch length (mm)    : $bunch_length\n";
		print TXT_FILE "Number of particles  : $bunch_number\n#\n";
	}
	elsif($pdf1 =~ /[Ee]quiv[^:]*[Pp]hoton/ || $pdf2 =~ /[Ee]quiv[^:]*[Pp]hoton/){
		print TXT_FILE "Photon particle           : $photon_particle\n";
		print TXT_FILE "|Q|max                    : ,$photon_Qmax\n";
	}
	elsif($pdf1 =~ /[Pp]roton[^:]*[Pp]hoton/ || $pdf2 =~ /[Pp]roton[^:]*[Pp]hoton/){
		print TXT_FILE "Incoming particle mass    : $photon_incoming_particle_mass\n";
		print TXT_FILE "Incoming particle charge  : $photon_incoming_particle_charge\n";
		print TXT_FILE "|Q^2|max                  : $photon_Q2max\n";
		print TXT_FILE "Pt cut of outgoing proton :  $photon_proton_ptCut\n";
	}
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Momenta                    #\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "p1 :         $p1\n";
	print TXT_FILE "p2 :         $p2\n\n";
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Parameters                 #\n";
	print TXT_FILE "#########################################\n";
	for (my $j=0;$j<=$#vars_names;$j++){
		print TXT_FILE "Parameter:   $vars_names[$j]=$vars_values[$j]\n";
	}
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            QCD running info           #\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE	"parton dist. alpha : $alphaPDF\n";
	print TXT_FILE	"alpha(MZ)          : $alphaMZ\n";
	print TXT_FILE "alpha nf           : $alphaNF\n";
	print TXT_FILE "alpha order        : $alphaOrder\n";
	print TXT_FILE "mb(mb)             : $alphaMbMb\n";
	print TXT_FILE "Mtop(pole)         : $alphaMtp\n";
	for (my $j=0;$j<=$#alphaScale;$j++){
		print TXT_FILE "alpha Q :".($alphaNumber[$j]+1).": $alphaScale[$j]\n";
	}
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Cuts                       #\n";
	print TXT_FILE "#########################################\n";
	for (my $j=0;$j<=$#cut_param;$j++){
		print TXT_FILE "Cut parameter :".($cut_Number[$j]+1).": $cut_param[$j]\n";
		print TXT_FILE "Cut invert    :".($cut_Number[$j]+1).": $cut_invert[$j]\n";
		print TXT_FILE "Cut min       :".($cut_Number[$j]+1).": $cut_min[$j]\n";
		print TXT_FILE "Cut max       :".($cut_Number[$j]+1).": $cut_max[$j]\n";
	}
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Kinematics                 #\n";
	print TXT_FILE "#########################################\n";
	for (my $j=0;$j<=$#kinematics;$j++){
		print TXT_FILE "Kinematics :".($kin_Number[$j]+1).": $kinematics[$j]\n";
	}
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Regularization             #\n";
	print TXT_FILE "#########################################\n";
	for (my $j=0;$j<=$#reg_mom;$j++){
		print TXT_FILE "Regularization momentum :".($reg_Number[$j]+1).": $reg_mom[$j]\n";
		print TXT_FILE "Regularization mass     :".($reg_Number[$j]+1).": $reg_mass[$j]\n";
		print TXT_FILE "Regularization width    :".($reg_Number[$j]+1).": $reg_width[$j]\n";
		print TXT_FILE "Regularization power    :".($reg_Number[$j]+1).": $reg_pow[$j]\n";
	}
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Distributions              #\n";
	print TXT_FILE "#########################################\n";
	for (my $j=0;$j<=$#dist_param;$j++){
		print TXT_FILE "Dist parameter          : $dist_param[$j]\n";
		print TXT_FILE "Dist min                : $dist_min[$j]\n";
		print TXT_FILE "Dist max                : $dist_max[$j]\n";
		print TXT_FILE "Dist n bins             : $dist_n_bins[$j]\n";
		print TXT_FILE "Dist title              : $dist_title[$j]\n";
		print TXT_FILE "Dist x-title            : $dist_x_title[$j]\n\n";

	}
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Events Generation          #\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "Number of events (per run step): $n_events\n";
	print TXT_FILE "Filename                       : $_[0]\n";
	#print TXT_FILE "File format                    : $fileFormat\n";
	print TXT_FILE "Cleanup                        : $cleanup\n";
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Parallelization info       #\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "Parallelization method : $par_meth\n";
	print TXT_FILE "Que                    : $que\n";
	print TXT_FILE "Walltime               : $walltime\n";
	print TXT_FILE "Memory                 : $memory\n";
	print TXT_FILE "email                  : $email\n";
	print TXT_FILE "Max number of cpus     : $max_cpus\n";
	print TXT_FILE "sleep time             : $sleep_time\n";
	print TXT_FILE "nice level             : $nice_level\n";
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#            Vegas                      #\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "nSess_1  : $nSess1\n";
	print TXT_FILE	"nCalls_1 : $nCalls1\n";
	print TXT_FILE "nSess_2  : $nSess2\n";
	print TXT_FILE	"nCalls_2 : $nCalls2\n";
	print TXT_FILE "\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "#           Event Generator             #\n";
	print TXT_FILE "#########################################\n";
	print TXT_FILE "sub-cubes      : $subCubes\n";
	print TXT_FILE	"random search  : $randSearch\n";
	print TXT_FILE "simplex search : $simpSearch\n";
	print TXT_FILE "MAX*N          : $maxN\n";
	print TXT_FILE "find new MAX   : $findNewMax\n"; 
	print TXT_FILE "\n\n";
	print TXT_FILE "</calchep-batch>\n";
	close(TXT_FILE);
}


####################################################
#                 Print index                      #
####################################################
sub print_index {
	open(TXT_FILE,  ">$html_dir/index.txt");
	open(HTML_FILE, ">$html_dir/index.html");
	############################
	#        Header            #
	############################
	print TXT_FILE "\n\tCalcHEP Batch Details\n\n";
	print HTML_FILE "<html>\n";
   print HTML_FILE "<head>\n";
   print HTML_FILE "\t<title>CalcHEP Batch Details</title>\n";
   print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
   print HTML_FILE "\t <link rel='stylesheet' href='style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
   ############################
   #        Body              #
   ############################
   print HTML_FILE "<body>\n";
   ############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='help/index.html'>Help</a></li>\n";
   print HTML_FILE "\t\t<br>\n";
	print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
	print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
   
	print HTML_FILE "<div id='main'>\n";
	print HTML_FILE "<h1>CalcHEP Batch Details</h1>\n";
	print HTML_FILE "<h2>$model_name</h2>\n";
	if    ($_[0]==-1){
		print HTML_FILE "<h3>Processing Batch File</h3>\n";
		print TXT_FILE "\tProcessing Batch File\n\n";
	}
	elsif ($_[0]==0){
		print HTML_FILE "<h3>Generating Symbolic Code</h3>\n";
		print TXT_FILE "\tGenerating Symbolic Code\n\n";
	}
	elsif ($_[0]==1){
		print HTML_FILE "<h3>Calculating Cross Sections</h3>\n";
		print TXT_FILE "\tCalculating Cross Sections\n\n";
	}
	elsif ($_[0]==1.5){
		print HTML_FILE "<h3>Done!</h3>\n";
		print TXT_FILE "\tDone!\n\n";
	}
	elsif ($_[0]==2){
		print HTML_FILE "<h3>Generating Events</h3>\n";
		print TXT_FILE "\tGenerating Events\n\n";
	}
	elsif ($_[0]==3){
		print HTML_FILE "<h3>Done!</h3>\n";
		print TXT_FILE "\tDone!\n\n";
	}
	print HTML_FILE "<table>\n";
	print HTML_FILE "\t<tr><th></th><th>Finished</th><th>Time(hr)</th></tr>\n";
	print TXT_FILE "\t\tFinished\tTime(hr)\n";
	if ($_[0]==0){
		print HTML_FILE "\t<tr><td><a href='symbolic.html'>Symbolic</a></td>";
		print TXT_FILE "Symbolic\t";
		if ($#all_subprocesses<0){
			print HTML_FILE "<td></td>";
			print TXT_FILE "\t\t\t";
		}
		else {
			print HTML_FILE "<td>".
				($#all_subprocesses+1-num_not_in_lib())."/".($#all_subprocesses+1)."</td>";
			print TXT_FILE 
				($#all_subprocesses+1-num_not_in_lib())."/".($#all_subprocesses+1)."\t\t";
		}
		if ($symb_begin_time>0){
			printf HTML_FILE "<td>%.2f</td></tr>\n",(time()-$symb_begin_time)/3600;
			printf TXT_FILE "%.2f\n",(time()-$symb_begin_time)/3600;
		}
		else {print HTML_FILE "\n";}
	}
	elsif($_[0]>0){
		printf HTML_FILE "\t<tr><td><a href='symbolic.html'>Symbolic</a></td><td>%i/%i</td><td>%.2f</td></tr>\n",$#all_subprocesses+1,$#all_subprocesses+1,($symb_end_time-$symb_begin_time)/3600;
		printf TXT_FILE "Symbolic\t%i/%i\t\t%.2f\n",
			$#all_subprocesses+1,$#all_subprocesses+1,($symb_end_time-$symb_begin_time)/3600;
	}
	if ($_[0]==1){
		print HTML_FILE "\t<tr><td><a href='numerical.html'>&sigma;</a></td>";
		print TXT_FILE "sigma\t\t";
		if ($#step<0){
			print HTML_FILE "<td>$runs_finished/1</a></td>";
			print TXT_FILE "$runs_finished/1\t\t";
		}
		else {
			printf HTML_FILE "<td>$runs_finished/%i</td>",$#step+1;
			printf TXT_FILE "$runs_finished/%i\t\t",$#step+1;
		}
		if ($cs_begin_time>0){
			printf HTML_FILE "<td>%.2f</td></tr>\n",(time()-$cs_begin_time)/3600;
			printf TXT_FILE "%.2f\n",(time()-$cs_begin_time)/3600;
		}
		else {
			print HTML_FILE "<td></td></tr>\n";
			print TXT_FILE "\n";
		}
	}
	elsif ($_[0]>1){
		print HTML_FILE "\t<tr><td><a href='numerical.html'>&sigma;</a></td>";
		print TXT_FILE "sigma\t\t";
		if ($#step<0){
			print HTML_FILE "<td>1/1</td>";
			print TXT_FILE "1/1\t\t";
		}
		else {
			printf HTML_FILE "<td>%i/%i</td>",$#step+1,$#step+1;
			printf TXT_FILE "%i/%i\t\t",$#step+1,$#step+1;
		}
		printf HTML_FILE "<td>%.2f</td></tr>\n",($cs_end_time-$cs_begin_time)/3600;
		printf TXT_FILE "%.2f\n",($cs_end_time-$cs_begin_time)/3600;
	}
	if ($_[0]==2){
		print HTML_FILE "\t<tr><td><a href='numerical.html'>Events</a></td>";
		print TXT_FILE "Events\t\t";
		if ($#step<0){
			print HTML_FILE "<td>$runs_finished/1</td>";
			print TXT_FILE "$runs_finished/1\t\t";
		}
		else {
			printf HTML_FILE "<td>$runs_finished/%i</td>",$#step+1;
			printf TXT_FILE "$runs_finished/%i\t\t",$#step+1;
		}
		if ($events_begin_time>0){
			printf HTML_FILE "<td>%.2f</td>",(time()-$events_begin_time)/3600;
			printf TXT_FILE "%.2f\n",(time()-$events_begin_time)/3600;
		}
		else {print HTML_FILE "<td></td></tr>\n";}
	}
	elsif ($_[0]>2){
		print HTML_FILE "\t<tr><td><a href='numerical.html'>Events</a></td>";
		print TXT_FILE "Events\t\t";
		if ($#step<0){
			print HTML_FILE "<td>1/1</td>";
			print TXT_FILE "1/1\t\t";
		}
		else {
			printf HTML_FILE "<td>%i/%i</td>",$#step+1,$#step+1;
			printf TXT_FILE "%i/%i\t\t",$#step+1,$#step+1;
		}
		printf HTML_FILE "<td>%.2f</td></tr>\n",($events_end_time-$events_begin_time)/3600;
		printf TXT_FILE "%.2f\n",($events_end_time-$events_begin_time)/3600;
	}
	print HTML_FILE "</table>\n";
	print TXT_FILE "\n";

	print HTML_FILE "</div>\n";
	print HTML_FILE "</body>\n";
	print HTML_FILE "</html>\n";
	close(HTML_FILE);
	close(TXT_FILE);
}

####################################################
#            Print Process Library                 #
####################################################
sub print_init_model_library {
	open(LIB_FILE, ">$working_dir/Processes/models.txt");
	print LIB_FILE "################################\n";
	print LIB_FILE "#        Models Library        #\n";
	print LIB_FILE "#    Automatically generated   #\n";
	print LIB_FILE "#     Do not edit this file    #\n";
	print LIB_FILE "################################\n";
	close(LIB_FILE);
}
sub print_init_library {
	open(LIB_FILE, ">$working_dir/Processes/$model_dir/processes.txt");
	print LIB_FILE "################################\n";
	print LIB_FILE "#       Processes Library      #\n";
	print LIB_FILE "#    Automatically generated   #\n";
	print LIB_FILE "#     Do not edit this file    #\n";
	print LIB_FILE "################################\n";
	close(LIB_FILE);
}
sub print_lib_index {
	open(LIB_FILE, ">>$working_dir/Processes/models.txt");
	print LIB_FILE "$_[0] : $_[1]\n";
	close(LIB_FILE);
	
	open (HTML_FILE, ">$html_dir/library.html");
	print HTML_FILE "<html>\n";
	print HTML_FILE "<head>\n";
   print HTML_FILE "\t<title>CalcHEP Process Library Index</title>\n";
   print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
   print HTML_FILE "\t <link rel='stylesheet' href='style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
   print HTML_FILE "<body>\n";
   ############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='help/index.html'>Help</a></li>\n";
   print HTML_FILE "\t\t<br>\n";
	print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
	print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
	
   print HTML_FILE "<div id='main'>\n";
   print HTML_FILE "\t<h1>Process Library Index</h1>\n";
   print HTML_FILE "\t<table>\n";
   print HTML_FILE "\t\t<tr><th>Model</th><th colspan='2'>Gauges</th></tr>\n";
   for (my $j=0;$j<=$#mod_dirs;$j++){
   	$model=$mod_names[$j];
   	$dir=$mod_dirs[$j];
   	print HTML_FILE "\t\t<tr><td>$model</td>";
   	@ggs = `ls $working_dir/Processes/$dir`;
   	if ($ggs[0] =~ /[Ff]eynman/ && $#ggs>0){
   		print HTML_FILE "<td><a href='$dir/Feynman/library.html'>Feynman</a></td><td><a href='$dir/Unitary/library.html'>Unitary</a></td></tr>\n";
   	}
   	elsif ($ggs[0] =~ /[Ff]eynman/){
   		print HTML_FILE "<td><a href='$dir/Feynman/library.html'>Feynman</a></td></tr>\n";
   	}
   	elsif ($ggs[0] =~ /[Uunitary]/){
   		print HTML_FILE "<td></td><td><a href='$dir/Unitary/library.html'>Unitary</a></td</tr>\n";
   	}
   }
   print HTML_FILE "\t</table>\n";
   print HTML_FILE "</div></body>\n";
   close(HTML_FILE);
}
sub print_library {
	open(LIB_FILE, ">>$working_dir/Processes/$model_dir/processes.txt");
	print LIB_FILE "$_[0] : $_[1] : $_[2]\n";
	close(LIB_FILE);
	
	#Create library directory if necessary
	$model_dir_tmp="m$model_num";
	if (!(-d "html/$model_dir_tmp")){system("mkdir html/$model_dir_tmp");}
	if (!(-d "html/$model_dir")){system("mkdir html/$model_dir");}
	
	#Write library.html
	open(HTML_FILE, ">$html_dir/$model_dir/library.html");
	print HTML_FILE "<html>\n";
   print HTML_FILE "<head>\n";
   print HTML_FILE "\t<title>CalcHEP Process Library</title>\n";
   print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
   print HTML_FILE "\t <link rel='stylesheet' href='../../style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
   print HTML_FILE "<body>\n";
   ############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='../../index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='../../request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='../../symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='../../numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='../../events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='../../library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='../../help/index.html'>Help</a></li>\n";
   print HTML_FILE "\t\t<br>\n";
	print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
	print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
	
   print HTML_FILE "<div id='main'>\n";
   print HTML_FILE "\t<h1>CalcHEP Process Library</h1>\n";
   print HTML_FILE "\t<h2>$model_name</h2>\n";
   print HTML_FILE "\t<h3>$gauge gauge</h3>\n";
   print HTML_FILE "\t<table>\n";
   print HTML_FILE "\t\t<tr><th>Directory</th><th>Process</th><th>Removes</th></tr>\n";
   
	for (my $j=0;$j<=$#lib_dirs;$j++){
		print HTML_FILE "\t\t<tr><td>$lib_dirs[$j]</td><td>$lib_procs[$j]</td><td>$lib_removes[$j]</td></tr>\n";
	}
	
	print HTML_FILE "\t</table>\n";
	print HTML_FILE "</div></body></html>\n";
	close(HTML_FILE);
}


####################################################
#                 Print symbolic                   #
####################################################
sub print_symbolic {
	open(HTML_FILE, ">$html_dir/symbolic.html");
	open(TXT_FILE, ">$html_dir/symbolic.txt");
	############################
	#        Header            #
	############################
	print TXT_FILE "\tCalcHEP Symbolic Details\n\n";
   print HTML_FILE "<html>\n";
   print HTML_FILE "<head>\n";
   print HTML_FILE "\t<title>CalcHEP Symbolic Details</title>\n";
   print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
   print HTML_FILE "\t <link rel='stylesheet' href='style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
   ############################
   #        Body              #
   ############################
   print HTML_FILE "<body>\n";
   ############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='help/index.html'>Help</a></li>\n";
   print HTML_FILE "\t\t<br>\n";
	print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
	print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
   
	print HTML_FILE "<div id='main'>\n";
	print HTML_FILE "<h1>Symbolic Sessions</h1>\n";
	print HTML_FILE "<h2>$model_name</h2>\n";

	############################
   #        Processes         #
   ############################
	print HTML_FILE "\t<table>\n";
	print HTML_FILE "\t\t<tr><th>Processes</th><th>Lib</th>";
	print TXT_FILE "Processes                Lib  ";
	if ($_[0]>=0){
		print HTML_FILE "<th>PID</th><th>Time(hr)</th>";
		print TXT_FILE "PID       Time";
	}
	print HTML_FILE "</tr>\n";
	print TXT_FILE "\n";
	for (my $j=0;$j<=$#all_subprocesses;$j++){
		print HTML_FILE "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/job.o'>$all_subprocesses[$j]</a></td>";
		printf TXT_FILE "%-25s",$all_subprocesses[$j];
		if ($all_subproc_in_lib[$j] == 1){
			print HTML_FILE "<td>&#10003;</td>";
			print TXT_FILE "x    ";
		}
		else {
			print HTML_FILE "<td></td>";
			print TXT_FILE "     ";
		}
		if ($pids[$j] != 0){
			print HTML_FILE "<td>$pids[$j]</td>";
			printf TXT_FILE "%-10d",$pids[$j];
		}
		else {
			print HTML_FILE "<td></td>";
			print TXT_FILE "          ";
		}
		if ($end_times[$j]>$begin_times[$j]){
			$time = ($end_times[$j] - $begin_times[$j])/3600;
			printf HTML_FILE "<td>%.2f</td>",$time;
			printf TXT_FILE "%.2f",$time;
		}
		elsif ($begin_times[$j]>0){
			$time = (time() - $begin_times[$j])/3600;
			printf HTML_FILE "<td>%.2f</td>",$time;
			printf TXT_FILE "%.2f",$time;
		}
		else {print HTML_FILE "<td></td>";}
		print HTML_FILE "</tr>\n";
		print TXT_FILE "\n";
	}
	#Now for the widths
	print HTML_FILE "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$widths_dir/job.o'>Widths</a></td>";
	printf TXT_FILE "%-25s","Widths";
	if ($widths_in_lib == 1){
		print HTML_FILE "<td>&#10003;</td>";
		print TXT_FILE "x    ";
	}
	else {
		print HTML_FILE "<td></td>";
		print TXT_FILE "     ";
	}
	if ($widths_pid != 0){
		print HTML_FILE "<td>$widths_pid</td>";
		printf TXT_FILE "%-10d",$widths_pid;
	}
	else {
		print HTML_FILE "<td></td>";
		print TXT_FILE "          ";
	}
	if ($widths_end_times>$widths_begin_time){
		$time = ($widths_end_time - $widths_begin_time)/3600;
		printf HTML_FILE "<td>%.2f</td>",$time;
		printf TXT_FILE "%.2f",$time;
	}
	elsif ($widths_begin_time>0){
		$time = (time() - $widths_begin_time)/3600;
		printf HTML_FILE "<td>%.2f</td>",$time;
		printf TXT_FILE "%.2f",$time;
	}
	else {print HTML_FILE "<td></td>";}
	print HTML_FILE "</tr>\n";
	print TXT_FILE "\n";
	
	print HTML_FILE "\t</table>\n";




   ############################
   #        Done              #
   ############################
	print HTML_FILE "</div>\n";
   print HTML_FILE "</body>\n";
   print HTML_FILE "</html>\n";
   print TXT_FILE "\n";
	close(HTML_FILE);
	close(TXT_FILE);
};


####################################################
#                 Print numerical                  #
####################################################
sub print_numerical {
	open(HTML_FILE, ">$html_dir/numerical.html");
	open(TXT_FILE, ">$html_dir/numerical.txt");
	############################
	#        Header            #
	############################
	print TXT_FILE "\tCalcHEP Numerical Details\n\n";
	print HTML_FILE "<html>\n";
   print HTML_FILE "<head>\n";
   print HTML_FILE "\t<title>CalcHEP Numerical Details</title>\n";
   print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
   print HTML_FILE "\t <link rel='stylesheet' href='style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
   ############################
   #        Body              #
   ############################
   print HTML_FILE "<body>\n";
   ############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='help/index.html'>Help</a></li>\n";
   print HTML_FILE "\t\t<br>\n";
	print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
	print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
   
	print HTML_FILE "<div id='main'>\n";
	print HTML_FILE "<h1>Numerical Sessions</h1>\n";
	print HTML_FILE "<h2>$model_name</h2>\n";
	if($_[0]==0){
		print HTML_FILE "<h3>Calculating Cross Sections</h3>\n";
		print TXT_FILE "\tCalculating Cross Sections\n\n";
	}
	elsif($_[0]==0.5){
		print HTML_FILE "<h3>Done!</h3>\n";
		print TXT_FILE "\tDone!\n\n";
	}
	elsif($_[0]==1){
		print HTML_FILE "<h3>Generating Events</h3>\n";
		print TXT_FILE "\tGenerating Events\n\n";
	}
	elsif($_[0]==2){
		print HTML_FILE "<h3>Done!</h3>\n";
		print TXT_FILE "\tDone!\n\n";
	}

	############################
   #        Processes         #
   ############################
	print HTML_FILE "\t<table>\n";
	print HTML_FILE "\t\t<tr><th>Runs</th><th>&sigma; (fb)</th><th>Running</th><th>Finished</th><th>Time (hr)</th><th>N events</th></tr>\n";
	print TXT_FILE "Runs                sigma (fb)     Running   Finished   Time (hr)   N events\n";
	
	my $tot_time=0;
	if($#step<0){
		my $total_time=0;
		my $running=0;
		my $finished=0;
		my $nevents_total=0;
		my $error="";
		my $cs_total=0;
		my $num_subs=$#subprocesses;
		if ($_[0]==0){$num_subs=$#subprocesses;}
		elsif ($_[0]>0.5){$num_subs=$#all_subprocesses+1;}
		for (my $j=0;$j<=$#subprocesses;$j++){
			$nevents_total += $nevents[$j];
			$cs_total += $cs[$j];
		}
		for (my $j=0;$j<=$num_subs;$j++){
			if ($begin_times[$j]>0&&$end_times[$j]>$begin_times[$j]){
				my $time = ($end_times[$j] - $begin_times[$j])/3600;
				$total_time += $time;
				$finished++;
			}
			elsif ($end_times[$j] eq "Error"){
				$error="Error";
			}
			elsif ($begin_times[$j]>0){
				my $time = (time() - $begin_times[$j])/3600;
				$total_time += $time;
				$running++;
			}
			
		}
		#Now for the widths
		if ($widths_begin_time>0&&$widths_end_time>$widths_begin_time){
			my $time = ($widths_end_time - $widths_begin_time)/3600;
			$total_time += $time;
			$finished++;
		}
		elsif ($widths_end_time eq "Error"){
			$error="Error";
		}
		elsif ($widths_begin_time>0){
			my $time = (time() - $widths_begin_time)/3600;
			$total_time += $time;
			$running++;
		}
		$tot_time=$total_time;
		my $line = sprintf("\t\t<tr><td><a href='runs/single.html'>Single</a></td><td>%.5g</td><td>%i/%i</td><td>%i/%i</td><td>%.2f</td><td><a href='$working_dir/Events/$event_filenames[0]'>%i</a></td>",
			1000*$final_cs[0],$running,$num_subs+1,$finished,$num_subs+1,$total_time,$nevents_final[0]);
		$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
		if ($error eq "Error"){print HTML_FILE "$line<td>Error</td></tr>\n";}
		else {print HTML_FILE "$line<td></td></tr>\n";}
		$line = sprintf("Single              %-15.4e%3i/%-6i%3i/%-7i%-12.2f%i",
			1000*$final_cs[0],$running,$num_subs+1,$finished,$num_subs+1,$total_time,$nevents_final[0]);
		if ($error eq "Error"){print TXT_FILE "$line\tError\n";}
		else {print TXT_FILE "$line\n";}
		
	}
	elsif($#step>=0) {
		for (my $k=0;$k<=$#step;$k++){
			my @step_tmp = @{$step[$k]};
			my $line = "";
			my $run_html_file = "";
			for (my $l=0;$l<=$#run_param;$l++){
				$line = sprintf("%s%s=%s ",$line, $run_param[$l], 
					$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
				$run_html_file = sprintf("%s%s%s",$run_html_file, $run_param[$l], 
					$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
			}
			my $run_html_name=$run_html_file;
			$run_html_file=$run_html_file.".html";
			my $total_time=0;
			my $running=0;
			my $finished=0;
			my $error="";
			my $cs_total=0;
			my $nevents_total=0;
			my $num_subs=$#subprocesses;
			if ($_[0]==0){$num_subs=$#subprocesses;}
			elsif ($_[0]>0.5){$num_subs=$#all_subprocesses+1;}
			for (my $j=0;$j<=$#subprocesses;$j++){
				$nevents_total += $nevents[$j][$k];
				$cs_total += $cs[$j][$k];
			}
			for (my $j=0;$j<=$num_subs;$j++){
				if ($begin_times[$j][$k]>0&&$end_times[$j][$k]>$begin_times[$j][$k]){
					$time = ($end_times[$j][$k] - $begin_times[$j][$k])/3600;
					$total_time += $time;
					$finished++;
				}
				elsif ($end_times[$j][$k] eq "Error"){
					$error="Error";
				}
				elsif ($begin_times[$j][$k]>0){
					$time = ( time() - $begin_times[$j][$k] )/3600;
					$total_time += $time;
					$running++;
				}
				
			}
			#Now for the widths
			if ($widths_begin_times[$k]>0&&$widths_end_times[$k]>$widths_begin_times[$k]){
				$time = ($widths_end_times[$k] - $widths_begin_times[$k])/3600;
				$total_time += $time;
				$finished++;
			}
			elsif ($widths_end_times[$k] eq "Error"){
				$error="Error";
			}
			elsif ($widths_begin_times[$k]>0){
				$time = ( time() - $widths_begin_times[$k] )/3600;
				$total_time += $time;
				$running++;
			}
			$tot_time = $tot_time + $total_time;
			my $line = sprintf("\t\t<tr><td><a href='runs/%s'>%s</a></td><td>%.5g</td><td>%i/%i</td><td>%i/%i</td><td>%.2f</td><td><a href='$working_dir/Events/$event_filenames[$k]'>%i</a></td>",
				$run_html_file,$line,1000*$final_cs[$k],$running,$num_subs+1,$finished,$num_subs+1,$total_time,$nevents_final[$k]);
			$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
			if ($error eq "Error"){print HTML_FILE "$line<td>Error</td></tr>\n";}
			else {print HTML_FILE "$line<td></td></tr>\n";}
			$line = sprintf("%-20s%-15.4e%3i/%-6i%3i/%-7i%-12.2f%i",
				$run_html_name,1000*$final_cs[$k],$running,$num_subs+1,$finished,$num_subs+1,$total_time,$nevents_final[$k]);
			if ($error eq "Error"){print TXT_FILE "$line\tError\n";}
			else {print TXT_FILE "$line\n";}
		}
	}	
	my $line = sprintf("\t\t<tr><td></td><td></td><td></td><td></td><td>%.2f</td></tr>\n",$tot_time);
	print HTML_FILE $line;
	$line = sprintf("                                                        %.2f\n",$tot_time);
	print TXT_FILE "$line\n";
	print HTML_FILE "\t</table>\n";


   ############################
   #        Done              #
   ############################
	print HTML_FILE "</div>\n";
   print HTML_FILE "</body>\n";
   print HTML_FILE "</html>\n";
	close(HTML_FILE);
	close(TXT_FILE);
	
	
	
	
	####################################################
	#        Print single numerical                    #
	####################################################
	if($#step<0){
		open(HTML_FILE, ">$html_dir/runs/single.html");
		open(TXT_FILE, ">$html_dir/runs/single.txt");
		############################
		#        Header            #
		############################
		print TXT_FILE "\tCalcHEP Numerical Details\n\n";
		print HTML_FILE "<html>\n";
   	print HTML_FILE "<head>\n";
   	print HTML_FILE "\t<title>CalcHEP Numerical Details</title>\n";
   	print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
   	print HTML_FILE "\t<link rel='stylesheet' href='../style.css' type='text/css'></link>\n";
		print HTML_FILE "</head>\n";
   	############################
   	#        Body              #
   	############################
   	print HTML_FILE "<body>\n";
   	############################
   	#        Links             #
   	############################
   	print HTML_FILE "\n\n<div id='links'>\n";
   	print HTML_FILE "\t<ul>\n";
   	print HTML_FILE "\t\t<li><a href='../index.html'>Home</a></li>\n";
   	#print HTML_FILE "\t\t<li><a href='../request.html'>Batch Request</a></li>\n";
   	print HTML_FILE "\t\t<li><a href='../symbolic.html'>Symbolic Results</a></li>\n";
   	print HTML_FILE "\t\t<li><a href='../numerical.html'>Numerical Results</a></li>\n";
   	print HTML_FILE "\t\t<li><a href='../events.html'>Events Library</a></li>\n";
		print HTML_FILE "\t\t<li><a href='../library.html'>Process Library</a></li>\n";
   	print HTML_FILE "\t\t<li><a href='../help/index.html'>Help</a></li>\n";
   	print HTML_FILE "\t\t<br>\n";
		print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
		print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   	print HTML_FILE "\t</ul>\n";
   	print HTML_FILE "</div>\n\n\n";
   
		print HTML_FILE "<div id='main'>\n";
		print HTML_FILE "<h1>Numerical Sessions</h1>\n";
		print HTML_FILE "<h2>$model_name</h2>\n";
		if($_[0]==0){
			print HTML_FILE "<h3>Calculating Cross Sections</h3>\n";
			print TXT_FILE "\tCalculating Cross Sections\n\n";
		}
		elsif($_[0]==0.5){
			print HTML_FILE "<h3>Done!</h3>\n";
			print TXT_FILE "\tDone!\n\n";
		}

		elsif($_[0]==1){
			print HTML_FILE "<h3>Generating Events</h3>\n";
			print TXT_FILE "\tGenerating Events\n\n";
		}
		elsif($_[0]==2){
			print HTML_FILE "<h3>Done!</h3>\n";
			print TXT_FILE "\tDone!\n\n";
		}

		############################
	   #        Processes         #
   	############################
		print HTML_FILE "\t<table>\n";
		if($_[0]<1){
			print HTML_FILE "\t\t<tr><th>Processes</th><th>&sigma; (fb)</th><th>PID</th><th>Time (hr)</th><th></th><th colspan='2'>Details</th></tr>\n";
			print TXT_FILE "Processes                sigma (fb)     PID       Time (hr)\n";
		}
		else {
			print HTML_FILE "\t\t<tr><th>Processes</th><th>&sigma; (fb)</th><th>PID</th><th>Time (hr)</th><th>N events</th><th colspan='2'>Details</th></tr>\n";
			print TXT_FILE "Processes                sigma (fb)     PID       Time (hr)      N events\n";
		}
		my $time = 0;
		my $total_time=0;
		my $cs_total=0;
		my $nevents_total=0;
		my $nevents_finished_total=0;
		my $error = "";
		my $num_subs=$#subprocesses;
		if ($_[0]==0){$num_subs=$#subprocesses;}
		elsif ($_[0]>0.5){$num_subs=$#all_subprocesses;}
		for(my $j=0;$j<=$#subprocesses;$j++){
			$nevents_total += $nevents[$j];
			$nevents_finished_total += $nevents_finished[$j];
			$cs_total += $cs[$j];
		}
		for(my $j=0;$j<=$#subprocesses;$j++){
			$time = 0;
			if ($begin_times[$j]>0&&$end_times[$j]>$begin_times[$j]){
				$time = ($end_times[$j] - $begin_times[$j])/3600;
				$total_time += $time;
			}
			elsif ($end_times[$j] eq "Error"){
				$error="Error";
			}
			elsif ($begin_times[$j]>0){
				$time = (time() - $begin_times[$j])/3600;
				$total_time += $time;
			}
			if ($_[0]<1){
				my $line = sprintf "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/cs.o'>%s</a></td><td>%.5g</td><td>%i</td><td>%.2f</td><td></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/prt_1'>prt_1</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/session.dat'>session.dat</a></td></tr>\n",
					$all_subprocesses[$j],1000*$cs[$j],$pids[$j],$time;
				$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
				print HTML_FILE $line;
				printf TXT_FILE "%-25s%-15.4e%-10i%-15.2f\n",
					$all_subprocesses[$j],1000*$cs[$j],$pids[$j],$time;
			}
			else {
				my $line = sprintf "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/job.o'>%s</a></td><td>%.5g</td><td>%i</td><td>%.2f</td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/events_1.txt'>%i/%i</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/prt_1'>prt_1</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/session.dat'>session.dat</a></td></tr>\n",
					$all_subprocesses[$j],1000*$cs[$j],$pids[$j],$time,$nevents_finished[$j],$nevents[$j];
				$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
				print HTML_FILE $line;
				printf TXT_FILE "%-25s%-15.4e%-10i%-15.2f%i/%i\n",
					$all_subprocesses[$j],1000*$cs[$j],$pids[$j],$time,$nevents_finished[$j],$nevents[$j];
			}		
		}
		my $line="";
		if($_[0]<1) {$line = sprintf("\t\t<tr><td>Total</td><td>%.5g</td><td></td><td>%.2f</td><td></td></tr>\n",1000*$cs_total,$total_time);}
		else {$line = sprintf("\t\t<tr><td>Total</td><td>%.5g</td><td></td><td></td><td>%i/%i</td></tr>\n",1000*$cs_total,$nevents_finished_total,$nevents_total);}
		$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
		print HTML_FILE $line;
		if($_[0]<1){$line = sprintf("Total                    %-15.4e          %-15.2f\n\n",	1000*$cs_total,$total_time);}
		else {$line = sprintf("Total                    %-15.4e                         %i/%i\n\n", 1000*$cs_total,$nevents_finished_total,$nevents_total);}
		print TXT_FILE $line;
		
		if($_[0]>0.5){
			#Now for the decays
			print HTML_FILE "\t\t<tr><td><br></td></tr>\n";
			print HTML_FILE "\t\t<tr><th>Decays</th><th>&Gamma; (GeV)</th><th>PID</th><th>Time (hr)</th><th>N events</th><th colspan='2'>Details</th></tr>\n";
			print TXT_FILE "Decays                   width (GeV)    PID       Time (hr)      N events\n";
			for(my $j=$#subprocesses+1;$j<=$num_subs;$j++){
				$time = 0;
				if ($begin_times[$j]>0&&$end_times[$j]>$begin_times[$j]){
					$time = ($end_times[$j] - $begin_times[$j])/3600;
					$total_time += $time;
				}
				elsif ($end_times[$j] eq "Error"){
					$error="Error";
				}
				elsif ($begin_times[$j]>0){
					$time = (time() - $begin_times[$j])/3600;
					$total_time += $time;
				}
				my $line = sprintf "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/job.o'>%s</a></td><td>%.5g</td><td>%i</td><td>%.2f</td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/events_1.txt'>%i/%i</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/prt_1'>prt_1</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/single/session.dat'>session.dat</a></td></tr>\n",
					$all_subprocesses[$j],$cs[$j],$pids[$j],$time,$nevents_finished[$j],$nevents[$j];
				$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
				print HTML_FILE $line;
				printf TXT_FILE "%-25s%-15.4e%-10i%-15.2f%i/%i\n",
					$all_subprocesses[$j],$cs[$j],$pids[$j],$time,$nevents_finished[$j],$nevents[$j];		
			}
		
			#Now for the widths
			print HTML_FILE "\t\t<tr><td><br></td></tr>\n";
			print HTML_FILE "\t\t<tr><th>Widths</th><th></th><th>PID</th><th>Time (hr)</th><th></th><th colspan='2'>Details</th></tr>\n";
			print TXT_FILE "\nWidths                                  PID       Time (hr)\n";
			$time = 0;
			if ($widths_begin_time>0&&$widths_end_time>$widths_begin_time){
				$time = ($widths_end_time - $widths_begin_time)/3600;
				$total_time += $time;
			}
			elsif ($widths_end_time eq "Error"){
				$error="Error";
			}
			elsif ($widths_begin_time>0){
				$time = (time() - $widths_begin_time)/3600;
				$total_time += $time;
			}
			
			my $line = sprintf "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$widths_dir/single/decaySLHA1.txt'>Widths</a></td><td></td><td>%i</td><td>%.2f</td><td></td><td></td><td><a href='$working_dir/Processes/$model_dir/$widths_dir/single/session.dat'>session.dat</a></td></tr>\n",
				$widths_pid,$time;
			$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
			print HTML_FILE $line;
			printf TXT_FILE "%-40s%-10i%-15.2f\n",
				"Widths",$widths_pid,$time;
		
			#Totals
			print HTML_FILE "\t\t<tr><td><br></td></tr>\n";
			my $line = sprintf("\t\t<tr><td>Total</td><td>%.5g</td><td></td><td>%.2f</td><td></td></tr>\n",1000*$final_cs[0],$total_time);
			$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
			print HTML_FILE $line;
			$line = sprintf("\nTotal                    %-15.4e   %-15.2f\n\n",1000*$final_cs[0], $total_time);
			print TXT_FILE $line;
		}
		print HTML_FILE "\t</table>\n\n";
		
		#Display plots
		print HTML_FILE "\t<h2>Distributions</h2>\n";
		@tmp_plot_filenames = @{$plot_filenames[0]};
		foreach my $filename (@tmp_plot_filenames){
			print HTML_FILE "\t<img src='../../Events/$filename'><br>\n";
		}

	   ############################
	   #        Done              #
	   ############################
		print HTML_FILE "</div>\n";
	   print HTML_FILE "</body>\n";
	   print HTML_FILE "</html>\n";
		close(HTML_FILE);
		close(TXT_FILE);
	}
	####################################################
	#        Print run numerical                       #
	####################################################
	else {for (my $k=0;$k<=$#step;$k++){
		my @step_tmp = @{$step[$k]};
		my $line = "";
		my $run_html_file = "";
		my $subdir_name = "";
		for (my $l=0;$l<=$#run_param;$l++){
			$line = sprintf("%s%s=%s ",$line, $run_param[$l], 
				$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
			$run_html_file = sprintf("%s%s%s",$run_html_file, $run_param[$l], 
				$run_begin[$l]+$run_step[$l]*$step_tmp[$l]);
			$subdir_name = $run_html_file;
		}
		open(TXT_FILE, ">$html_dir/runs/$run_html_file.txt");
		$run_html_file=$run_html_file.".html";
		open(HTML_FILE, ">$html_dir/runs/$run_html_file");
		############################
		#        Header            #
		############################
		print TXT_FILE "\tCalcHEP Numerical Details\n\n";
		print HTML_FILE "<html>\n";
   	print HTML_FILE "<head>\n";
   	print HTML_FILE "\t<title>CalcHEP Numerical Details</title>\n";
   	print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
   	print HTML_FILE "\t<link rel='stylesheet' href='../style.css' type='text/css'></link>\n";
		print HTML_FILE "</head>\n";
   	############################
   	#        Body              #
   	############################
   	print HTML_FILE "<body>\n";
   	############################
   	#        Links             #
   	############################
   	print HTML_FILE "\n\n<div id='links'>\n";
   	print HTML_FILE "\t<ul>\n";
   	print HTML_FILE "\t\t<li><a href='../index.html'>Home</a></li>\n";
   	#print HTML_FILE "\t\t<li><a href='../request.html'>Batch Request</a></li>\n";
   	print HTML_FILE "\t\t<li><a href='../symbolic.html'>Symbolic Results</a></li>\n";
   	print HTML_FILE "\t\t<li><a href='../numerical.html'>Numerical Results</a></li>\n";
   	print HTML_FILE "\t\t<li><a href='../events.html'>Events Library</a></li>\n";
   	print HTML_FILE "\t\t<li><a href='../library.html'>Process Library</a></li>\n";
   	print HTML_FILE "\t\t<li><a href='../help/index.html'>Help</a></li>\n";
   	print HTML_FILE "\t\t<br>\n";
		print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
		print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   	print HTML_FILE "\t</ul>\n";
   	print HTML_FILE "</div>\n\n\n";
   
		print HTML_FILE "<div id='main'>\n";
		print HTML_FILE "<h1>Numerical Sessions</h1>\n";
		print HTML_FILE "<h2>$model_name</h2>\n";
		if($_[0]==0){
			print HTML_FILE "<h3>Calculating Cross Sections</h3>\n";
			print TXT_FILE "\tCalculating Cross Sections\n\n";
		}
		elsif($_[0]==0.5){
			print HTML_FILE "<h3>Done!</h3>\n";
			print TXT_FILE "\tDone!\n\n";
		}
		elsif($_[0]==1){
			print HTML_FILE "<h3>Generating Events</h3>\n";
			print TXT_FILE "\tGenerating Events\n\n";
		}
		elsif($_[0]==2){
			print HTML_FILE "<h3>Done!</h3>\n";
			print TXT_FILE "\tDone!\n\n";
		}

		############################
	   #        Processes         #
   	############################
		print HTML_FILE "\t<table>\n";
		if($_[0]<1){
			print HTML_FILE "\t\t<tr><th>Processes</th><th>&sigma; (fb)</th><th>PID</th><th>Time (hr)</th><th></th><th colspan='2'>Details</th></tr>\n";
			print TXT_FILE "Processes                sigma (fb)     PID       Time (hr)\n";
		}
		else {
			print HTML_FILE "\t\t<tr><th>Processes</th><th>&sigma; (fb)</th><th>PID</th><th>Time (hr)</th><th>N events</th><th colspan='2'>Details</th></tr>\n";
			print TXT_FILE "Processes                sigma (fb)     PID       Time (hr)      N events\n";
		}
		my $time = 0;
		my $total_time=0;
		my $cs_total=0;
		my $nevents_total=0;
		my $nevents_finished_total=0;
		my $error = "";
		my $num_subs=$#subprocesses;
		if ($_[0]==0){$num_subs=$#subprocesses;}
		elsif ($_[0]>0.5){$num_subs=$#all_subprocesses;}
		for(my $j=0;$j<=$#subprocesses;$j++){
			$nevents_total += $nevents[$j][$k];
			$nevents_finished_total += $nevents_finished[$j][$k];
			$cs_total += $cs[$j][$k];
		}
		for(my $j=0;$j<=$#subprocesses;$j++){
			$time = 0;
			if ($begin_times[$j][$k]>0&&$end_times[$j][$k]>$begin_times[$j][$k]){
				$time = ($end_times[$j][$k] - $begin_times[$j][$k])/3600;
				$total_time += $time;
			}
			elsif ($end_times[$j][$k] eq "Error"){
				$error="Error";
			}
			elsif ($begin_times[$j][$k]>0){
				$time = (time() - $begin_times[$j][$k])/3600;
				$total_time += $time;
			}
			if ($_[0]<1){
				my $line = sprintf "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/cs.o'>%s</a></td><td>%.5g</td><td>%i</td><td>%.2f</td><td></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/prt_1'>prt_1</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/session.dat'>session.dat</a></td></tr>\n",
					$all_subprocesses[$j],1000*$cs[$j][$k],$pids[$j][$k],$time;
				$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
				print HTML_FILE $line;
				printf TXT_FILE "%-25s%-15.4e%-10i%-15.2f\n",
					$all_subprocesses[$j],1000*$cs[$j][$k],$pids[$j][$k],$time;
			}
			else {
				my $line = sprintf "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/job.o'>%s</a></td><td>%.5g</td><td>%i</td><td>%.2f</td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/events_1.txt'>%i/%i</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/prt_1'>prt_1</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/session.dat'>session.dat</a></td></tr>\n",
					$all_subprocesses[$j],1000*$cs[$j][$k],$pids[$j][$k],$time,$nevents_finished[$j][$k],$nevents[$j][$k];
				$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
				print HTML_FILE $line;
				printf TXT_FILE "%-25s%-15.4e%-10i%-15.2f%i/%i\n",
					$all_subprocesses[$j],1000*$cs[$j][$k],$pids[$j][$k],$time,$nevents_finished[$j][$k],$nevents[$j][$k];
			}
			
		}
		my $line="";
		if($_[0]<1) {$line = sprintf("\t\t<tr><td>Total</td><td>%.5g</td><td></td><td>%.2f</td><td></td></tr>\n",1000*$cs_total,$total_time);}
		else {$line = sprintf("\t\t<tr><td>Total</td><td>%.5g</td><td></td><td></td><td>%i/%i</td></tr>\n",1000*$cs_total,$nevents_finished_total,$nevents_total);}
		$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
		print HTML_FILE $line;
		if($_[0]<1){$line = sprintf("Total                    %-15.4e          %-15.2f\n\n",	1000*$cs_total,$total_time);}
		else {$line = sprintf("Total                    %-15.4e                         %i/%i\n\n", 1000*$cs_total,$total_time,$nevents_finished_total,$nevents_total);}
		print TXT_FILE $line;
		
		if($_[0]>0.5){
			#Now for the decays
			print HTML_FILE "\t\t<tr><td><br></td></tr>\n";
			print HTML_FILE "\t\t<tr><th>Decays</th><th>&Gamma; (GeV)</th><th>PID</th><th>Time (hr)</th><th>N events</th><th colspan='2'>Details</th></tr>\n";
			print TXT_FILE "Decays                   width (GeV)    PID       Time (hr)      N events\n";
			for(my $j=$#subprocesses+1;$j<=$num_subs;$j++){
				$time = 0;
				if ($begin_times[$j][$k]>0&&$end_times[$j][$k]>$begin_times[$j][$k]){
					$time = ($end_times[$j][$k] - $begin_times[$j][$k])/3600;
					$total_time += $time;
				}
				elsif ($end_times[$j][$k] eq "Error"){
					$error="Error";
				}
				elsif ($begin_times[$j][$k]>0){
					$time = (time() - $begin_times[$j][$k])/3600;
					$total_time += $time;
				}
				my $line = sprintf "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/job.o'>%s</a></td><td>%.5g</td><td>%i</td><td>%.2f</td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/events_1.txt'>%i/%i</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/prt_1'>prt_1</a></td><td><a href='$working_dir/Processes/$model_dir/$all_subproc_dir[$j]/$subdir_name/session.dat'>session.dat</a></td></tr>\n",
					$all_subprocesses[$j],$cs[$j][$k],$pids[$j][$k],$time,$nevents_finished[$j][$k],$nevents[$j][$k];
				$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
				print HTML_FILE $line;
				printf TXT_FILE "%-25s%-15.4e%-10i%-15.2f%i/%i\n",
					$all_subprocesses[$j],$cs[$j][$k],$pids[$j][$k],$time,$nevents_finished[$j][$k],$nevents[$j][$k];
				
			
			}
			
			
			#Now for the widths
			print HTML_FILE "\t\t<tr><td><br></td></tr>\n";
			print HTML_FILE "\t\t<tr><th>Widths</th><th></th><th>PID</th><th>Time (hr)</th><th></th><th colspan='2'>Details</th></tr>\n";
			print TXT_FILE "\nWidths                                  PID       Time (hr)\n";
			$time = 0;
			if ($widths_begin_times[$k]>0&&$widths_end_times[$k]>$widths_begin_times[$k]){
				$time = ($widths_end_times[$k] - $widths_begin_times[$k])/3600;
				$total_time += $time;
			}
			elsif ($widths_end_times[$k] eq "Error"){
				$error="Error";
			}
			elsif ($widths_begin_times[$k]>0){
				$time = (time() - $widths_begin_times[$k])/3600;
				$total_time += $time;
			}
			my $line = sprintf "\t\t<tr><td><a href='$working_dir/Processes/$model_dir/$widths_dir/$subdir_name/decaySLHA1.txt'>Widths</a></td><td></td><td>%i</td><td>%.2f</td><td></td><td></td><td><a href='$working_dir/Processes/$model_dir/$widths_dir/$subdir_name/session.dat'>session.dat</a></td></tr>\n",
				$widths_pids[$k],$time;
			$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
			print HTML_FILE $line;
			printf TXT_FILE "%-25s%-15.4e%-10i%-15.2f%i/%i\n",
				"Widths",0,$widths_pids[$k],$time,0,0;
			
			
			#Totals
			print HTML_FILE "\t\t<tr><td><br></td></tr>\n";
			my $line = sprintf("\t\t<tr><td>Total</td><td>%.5g</td><td></td><td>%.2f</td><td></td></tr>\n",1000*$final_cs[$k],$total_time);
			$line =~ s|e([\+\-][0-9]+)| x10<sup>$1<\/sup>|;
			print HTML_FILE $line;
			$line = sprintf("\n%-25s%-15.4e   %-15.2f\n\n","Total",1000*$final_cs[$k], $total_time);
			print TXT_FILE $line;
		}		
		
		
		print HTML_FILE "\t</table>\n";


		#Display plots
		print HTML_FILE "\t<h2>Distributions</h2>\n";
		@tmp_plot_filenames = @{$plot_filenames[$k]};
		foreach my $filename (@tmp_plot_filenames){
			print HTML_FILE "\t<img src='../../Events/$filename'><br>\n";
		}

		
	   ############################
	   #        Done              #
	   ############################
		print HTML_FILE "</div>\n";
	   print HTML_FILE "</body>\n";
	   print HTML_FILE "</html>\n";
		close(HTML_FILE);
		close(TXT_FILE);
	}}
};




####################################################
#            Print particle not found              #
####################################################
sub print_particle_not_found {
	open(HTML_FILE, ">$html_dir/index.html");
	print HTML_FILE "<html>\n";
   print HTML_FILE "<head>\n";
   print HTML_FILE "\t<title>CalcHEP Batch Details</title>\n";
   print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
    print HTML_FILE "\t <link rel='stylesheet' href='style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
   print HTML_FILE "<body>\n";
	############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='help/index.html'>Help</a></li>\n";
   print HTML_FILE "\t\t<br>\n";
	print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
	print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
	
	print HTML_FILE "<div id='main'>\n";
  	print HTML_FILE "<h1>Particle Not Found</h1>\n";
   print HTML_FILE "<h2>Particle '$_[0]' was not found in '$model_name' model.</h2>\n";
   print HTML_FILE "<p>Please check the batch file and make sure it is correct.</p>\n";
	print HTML_FILE "</div>\n";
	print HTML_FILE "</body></html>\n";
	close(HTML_FILE);
};

####################################################
#                 Print No Batch File              #
####################################################
sub print_no_batch_file {
	open(HTML_FILE, ">$html_dir/index.html");
	print HTML_FILE "<html>\n";
   print HTML_FILE "<head>\n";
   print HTML_FILE "\t<title>CalcHEP Batch Details</title>\n";
   print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
    print HTML_FILE "\t <link rel='stylesheet' href='style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
   print HTML_FILE "<body>\n";
	############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='help/index.html'>Help</a></li>\n";
   print HTML_FILE "\t\t<br>\n";
	print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
	print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
	print HTML_FILE <<END_HTML;
	<div id='help_main'>
	<h1>Missing Batch File</h1>
	<p>
		Batch file '$batch_file_name' could not be found.  Please refer to the <a href='help/index.html'>help section</a>`.
	</p>
	</div>
	</body></html>
END_HTML
	
	print "\n\nMissing Batch File\n\n";
	print "\tBatch file '$batch_file_name' could not be found.\n";
   print "\tPlease refer to the html help files found in:\n";
   print "\tfile://${working_dir}/html/help/index.html\n\n";
};


####################################################
#                 Print Model Changed              #
####################################################
sub print_model_changed {
	open(HTML_FILE, ">$html_dir/index.html");
	print HTML_FILE "<html>\n";
   print HTML_FILE "<head>\n";
   print HTML_FILE "\t<title>CalcHEP Batch Details</title>\n";
   print HTML_FILE "\t<meta http-equiv='refresh' content='$sleep_time'>\n";
    print HTML_FILE "\t <link rel='stylesheet' href='style.css' type='text/css'></link>\n";
	print HTML_FILE "</head>\n";
   print HTML_FILE "<body>\n";
	############################
   #        Links             #
   ############################
   print HTML_FILE "\n\n<div id='links'>\n";
   print HTML_FILE "\t<ul>\n";
   print HTML_FILE "\t\t<li><a href='index.html'>Home</a></li>\n";
   #print HTML_FILE "\t\t<li><a href='request.html'>Batch Request</a></li>\n";
   print HTML_FILE "\t\t<li><a href='symbolic.html'>Symbolic Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='numerical.html'>Numerical Results</a></li>\n";
   print HTML_FILE "\t\t<li><a href='events.html'>Events Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='library.html'>Process Library</a></li>\n";
   print HTML_FILE "\t\t<li><a href='help/index.html'>Help</a></li>\n";
   print HTML_FILE "\t\t<br>\n";
	print HTML_FILE "\t\t<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>\n";
	print HTML_FILE "\t\t<li>Please cite <a href=''>arXiv:0000.0000</a></li>\n";
   print HTML_FILE "\t</ul>\n";
   print HTML_FILE "</div>\n\n\n";
	
	print HTML_FILE "<div id='help_main'>\n";
   print HTML_FILE "<h1>Model Changed</h1>\n";
   print HTML_FILE "<h2>Model changed was set to true</h2>\n";
   print HTML_FILE "<p>If the model was changed, the process library has to be deleted and redone.</p>\n";
   print HTML_FILE "<p>If the only changes to the model were changes in the numerical values of the ".
   	"variables, this does not require the process library to be deleted and redone.  If this is the ".
   	"only change, you can set 'Model changed' to 'No' or 'False' and rerun this program.</p>\n";
   print HTML_FILE "<p>If, on the other hand, changes were made to particles, constraints or vertices, the process library for this model must be deleted and redone.  To do this, delete the directory</p><center>$working_dir/Processes/$model_dir/.</center><p>After deleting this directory, set 'Model changed' to 'No' or 'False' and rerun this program.</p>\n";
   print HTML_FILE "</div>\n";
	print HTML_FILE "</body></html>\n";
	close(HTML_FILE);
	
	
	print "\n\nModel Changed\n\n";
	print "\tModel changed was set to true in the batch file.\n";
	print "\tIf the model was changed, the process library\n";
	print "\t\thas to be deleted and redone.\n";
	print "\tIf the only changes to the model were changes\n";
	print "\t\tin the numerical values of the variables,\n";
	print "\t\tthis does not require the process library to\n";
	print "\t\tbe deleted and redone.  If this is the only change,\n";
	print "\t\tyou can set 'Model changed' to 'No' or 'False'\n";
	print "\t\tand rerun this program.\n";
	print "\tIf, on the other hand, changes were made to particles,\n";
	print "\t\tconstraints or vertices, the process library for\n";
	print "\t\tthis model must be deleted and redone.  To do this,\n";
	print "\t\tdelete the directory:\n";
	print "\t\t$working_dir/Processes/$model_dir/\n";
	print "\t\tAfter deleting this directory, set 'Model changed'\n";
	print "\t\tto 'No' or 'False' and rerun this program.\n\n";
   print "\tPlease refer to the html help files found in:\n";
   print "\tfile://${working_dir}/html/help/index.html\n\n";
};




####################################################
#                 Print Help                       #
####################################################
sub print_help_batch_links {
	open(HTML_FILE, ">$_[0]");
	print HTML_FILE <<ENDHTML;
<html>
<head>
	<title>CalcHEP Batch Help</title>
	<link rel='stylesheet' href='../style.css' type='text/css'></link>
</head>
<body>
	<div id='links'>
		<ul>
			<li><a href='../index.html'>Home</a></li>
			<li><a href='../symbolic.html'>Symbolic Results</a></li>
			<li><a href='../numerical.html'>Numerical Results</a></li>
			<li><a href='../events.html'>Events Library</a></li>
			<li><a href='../library.html'>Process Library</a></li>
			<li><a href='index.html'>Help</a>
				<ul>
					<li><a href='batch_file.html'>Batch File</a><ul>
						<li><a href='comment.html'>Comments</a></li>
						<li><a href='model.html'>Model</a></li>
						<li><a href='process.html'>Process</a></li>
						<li><a href='pdf.html'>PDF</a></li>
						<li><a href='momentum.html'>Momentum</a></li>
						<li><a href='parameters.html'>Parameters</a></li>
						<li><a href='runs.html'>Runs</a></li>
						<li><a href='qcd.html'>QCD</a></li>
						<li><a href='cuts.html'>Cuts</a></li>
						<li><a href='kinematics.html'>Kinematics</a></li>
						<li><a href='regularization.html'>Regularization</a></li>
						<li><a href='distributions.html'>Distribution</a></li>
						<li><a href='events.html'>Events</a></li>
						<li><a href='parallelization.html'>Parallelization</a></lii>
						<li><a href='vegas.html'>Vegas</a></li>
						<li><a href='generator.html'>Generator</a></li>
						<li><a href='example1.html'>Example 1</a></li>
						<li><a href='example2.html'>Example 2</a></li>
						<li><a href='example3.html'>Example 3</a></li>
					</ul></li>
					<li><a href='process_library.html'>Process Library</a></li>
					<li><a href='event_library.html'>Event Library</a></li>
				</ul>
			</li>
			<br>
			<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>
			<li>Please cite <a href=''>arXiv:0000.0000</a></li>
		</ul>
	</div>
ENDHTML
	close(HTML_FILE);
}
sub print_help {
	print_help_index();
	print_help_batch_file();
	print_help_comments();
	print_help_model();
	print_help_process();
	print_help_pdf();
	print_help_momentum();
	print_help_parameters();
	print_help_runs();
	print_help_qcd();
	print_help_cuts();
	print_help_kinematics();
	print_help_regularization();
	print_help_distributions();
	print_help_events();
	print_help_parallelization();
	print_help_vegas();
	print_help_generator();
	print_help_example1();
	print_help_example2();
	print_help_example3();
	print_help_process_library();
	print_help_event_library();
}

sub print_help_index {
	open(HTML_FILE, ">$html_dir/help/index.html");
	print HTML_FILE <<ENDHTML;
<html>
<head>
	<title>CalcHEP Batch Help</title>
	<link rel='stylesheet' href='../style.css' type='text/css'></link>
</head>
<body>
	<div id='links'>
		<ul>
			<li><a href='../index.html'>Home</a></li>
			<li><a href='../symbolic.html'>Symbolic Results</a></li>
			<li><a href='../numerical.html'>Numerical Results</a></li>
			<li><a href='../events.html'>Events Library</a></li>
			<li><a href='../library.html'>Process Library</a></li>
			<li><a href='index.html'>Help</a>
				<ul>
					<li><a href='batch_file.html'>Batch File</a></li>
					<li><a href='process_library.html'>Process Library</a></li>
					<li><a href='event_library.html'>Event Library</a></li>
				</ul>
			</li>
			<br>
			<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>
			<li>Please cite <a href=''>arXiv:0000.0000</a></li>
		</ul>
	</div>	
	<div id='help_main'>
		<h1>Help</h1>
		<h3>Running</h3>
		<p>
			The batch script can be run in two ways.  It can be run directly from the run_batch perl script located in the bin directory as in
			<table>
				<tr><td>bin/./run_batch batch_file</td></tr>
			</table>
			where batch_file is the file that contains the instructions for the batch script.  If this method is used, the environment variable \$CALCHEP must first be set which refers to the CalcHEP main directory.  The batch script can also be invoked with the calchep_batch shell script in the users directory as in
			<table>
				<tr><td>./calchep_batch batch_file</td></tr>
			</table>
			where, again, batch_file is the file that contains the instructions for the batch script.  The default calchep_batch shell script automatically sets the \$CALCHEP environment variable and then invokes run_batch from the bin directory.  As the batch script runs, it continuously updates these html files with the current progress of the batch.  The frequency of the updates can be set in the batch file with the key phrase <a href='parallelization.html'>"sleep time"</a>.
		</p>
		<h3>Help Topics</h3>
		<p>
			Please choose the help topic from the menu on the left.
		</p>
                <h3>Warning</h3>
                <p>Please, please, please check the prt_1 files to make sure that the parameters, cuts, scales, etc. are exactly the way you intended.</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}

sub print_help_batch_file {
	print_help_batch_links("$html_dir/help/batch_file.html");
	open(HTML_FILE, ">>$html_dir/help/batch_file.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Batch File Help</h1>
		<p>
			This script is designed to be used in batch mode.  All the information about the batch is included by the user in a batch file.  The batch file can be named anything the user likes and is specified as the first argument of the batch script.  Most of the information available in CalcHEP is available in the batch file.  We describe each section of the batch file in these help files.  You can access each one by clicking on the links to the left.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}


sub print_help_comments {
	print_help_batch_links("$html_dir/help/comment.html");
	open(HTML_FILE, ">>$html_dir/help/comment.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Comment Help</h1>
		<p>
			Any line beginning with a # is ignored by run_batch.  The # has to be at the very beginning of the line.  Some examples are:<br>
		<table>
			<tr><td># This is ignored.</td></tr>
			<tr><td>#Model:         Standard Model	   This is ignored.</td></tr>
			<tr><td>Model:     #   Standard Model(CKM=1)    This is not ignored.</td></tr>
		</table>
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}

sub print_help_model {
	print_help_batch_links("$html_dir/help/model.html");
	open(HTML_FILE, ">>$html_dir/help/model.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Model Help</h1>
		<h3>Model</h3>
		<p>
			The first section of the batch file should contain the specification of the model.  This is done by model name and should match exactly the name in the CalcHEP model list.  So, if you want to run the \"Standard Model(CKM=1)\", you would specify this with the batch file line:<br>
			<table>
				<tr><td>Model</td><td>:</td><td>Standard Model(CKM=1)</td></tr>
			</table>
			There is no default for this line.  It must be included.
		</p>
		<h3>Model changed</h3>
		<p>
			After specifying the model name, a line specifying whether the model has been changed should be included.  This line is necessary because this batch program keeps a <a href='process_library.html'>library of processes</a>.  If the model is changed, each process is changed and the library has to be regenerated.  Simply changing the numerical values of independent variables does not require that the library be redone.  However, any other change, such as a change to a vertex, or to the expression of a dependent variable requires that the library be regenerated.  Whether or not the model is changed is specified with the keyphrase \"Model changed\" and can be either \"True\" or \"False\" as in:<br>
			<table>
				<tr><td>Model changed</td><td>:</td><td>False</td></tr>
			</table>
			The default is false.  If set to true, the batch script will print instructions to these html files describing which directory should be removed.
		</p>
		<h3>Gauge</h3>
		<p>
		The gauge of the calculation should also be specified in this section.  Choices are Feynman and unitary gauge.  CalcHEP is much better suited to calculation in Feynman gauge, but there may be times that unitary gauge is useful.  This can be specified using the keyword \"Gauge\" as in:<br>
			<table>
				<tr><td>Gauge</td><td>:</td><td>unitary</td></tr>
			</table>
			The default is Feynman.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}


sub print_help_process {
	print_help_batch_links("$html_dir/help/process.html");
	open(HTML_FILE, ">>$html_dir/help/process.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Process Help</h1>
		<h3>Process</h3>
		<p>
			Processes are specified using the \"Process\" keyword and standard CalcHEP notation as in:<br>
			<table>
				<tr><td>Process</td><td>:</td><td>p,p->j,l,l</td></tr>
			</table>
			Multiple processes can also be specified as in:<br>
			<table>
				<tr><td>Process</td><td>:</td><td>p,p->E,ne</td></tr>
				<tr><td>Process</td><td>:</td><td>p,p->M,nm</td></tr>
			</table>
			As many processes as desired can be specified.  When more than one process is specified, the processes are numbered by the order in which they are specified in the batch file.  So, in this example, p,p->E,ne is process 1 and p,p->M,nm is process 2.  This numbering can be useful when specifying <a href='qcd.html'>QCD scale</a>, <a href='cuts.html'>cuts</a>, <a href='kinematics.html'>kinematics</a>, <a href='regularization.html'>regularization</a> and <a href='distributions.html'>distributions</a> allowing these to be specified separately for each process.  There is no default for this keyword.  It must be specified.
		</p>
		<h3>Decay</h3>
		<p>
			Decays are specified using the \"Decay\" keyword and are also in standard CalcHEP notation as in:<br>
			<table>
				<tr><td>Decay</td><td>:</td><td>W->l,nu</td></tr>
			</table>
			Again, multiple decays can be specified as in:<br>
			<table>
				<tr><td>Decay</td><td>:</td><td>W->l,nu</td></tr>
				<tr><td>Decay</td><td>:</td><td>Z->l,l</td></tr>
			</table>
			The default is to not have any decays.  <a href='cuts.html'>Cuts</a>, <a href='kinematics.html'>kinematics</a>, <a href='regularization.html'>regularization</a> and <a href='distributions.html'>distributions</a> do not apply to decays.
		</p>
		<h3>Composite</h3>
		<p>
			It is sometimes convenient to specify groups of particles as in the particles that compose the proton or all the leptons.  This can be done with the keyword \"Composite\" as in:<br>
			<table>
				<tr><td>Composite</td><td>:</td><td>p=u,d,U,D,G</td></tr>
				<tr><td>Composite</td><td>:</td><td>l=e,E,m,M</td></tr>
				<tr><td>Composite</td><td>:</td><td>nu=ne,Ne,nm,Nm</td></tr>
				<tr><td>Composite</td><td>:</td><td>W=W+,W-</td></tr>
			</table>
			As many composite particles as necessary can be specified.  These definitions can be used in <a href='cuts.html'>cuts</a> and <a href='distributions.html'>distributions</a> as well as in the processes and decays.  The default is not to have any composite definitions.
			
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}


sub print_help_pdf {
	print_help_batch_links("$html_dir/help/pdf.html");
	open(HTML_FILE, ">>$html_dir/help/pdf.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>PDF Help</h1>
		<h3>PDF</h3>
		<p>
			The PDF of a proton or antiproton can be specified with the \"pdf1\" and \"pdf2\" kewords which correspond to the pdfs of the first and second incoming particles respectively.  Choices for these keywords are:<br>
			<table>
				<tr><td>cteq6l (anti-proton)    </td></tr>
		   	<tr><td>cteq6l (proton)         </td></tr>
    			<tr><td>mrst2002lo (anti-proton)</td></tr>
    			<tr><td>mrst2002lo (proton)     </td></tr>
    			<tr><td>cteq6m (anti-proton)    </td></tr>
    			<tr><td>cteq6m (proton)         </td></tr>
    			<tr><td>cteq5m (anti-proton)    </td></tr>
    			<tr><td>cteq5m (proton)         </td></tr>
    			<tr><td>mrst2002nlo (anti-proton)</td></tr>
    			<tr><td>mrst2002nlo (proton)    </td></tr>
    			<tr><td>None                    </td></tr>
    		</table>
    		An example for the LHC is:<br>
    		<table>
    			<tr><td>pdf1</td><td>:</td><td>cteq6l (proton)</td></tr>
    			<tr><td>pdf2</td><td>:</td><td>cteq6l (proton)</td></tr>
    		</table>
    		The default is none.  These keywords can also be used for electron positron colliders.  For this process the available pdfs are:<br>
    		<table>
    			<tr><td>ISR                     </td></tr>
    			<tr><td>ISR & Beamstrahlung     </td></tr>
    			<tr><td>Equiv. Photon           </td></tr>
    			<tr><td>Laser photons           </td></tr>
    			<tr><td>None                    </td></tr>
    		</table>
    		The following proton electron collider pdf is also available:<br>
    		<table>
    			<tr><td>Proton Photon           </td></tr>
    		</table>
    		All of these pdfs must be typed exactly or copied into the batch file.  
		</p>
		<h3>Bunch Specification</h3>
		<p>
			If \"ISR & Beam\" is chosen, then the following beam parameters may be specified:<br>
    		<table>
    			<tr><td>Bunch x+y sizes (nm)</td><td>:</td><td>550</td></tr>
    			<tr><td>Bunch length (mm)</td><td>:</td><td>0.45</td></tr>
				<tr><td>Number of particles</td><td>:</td><td>2.1E+10</td></tr>
			</table>
    		The default values are the default values in CalcHEP and correspond roughly with the ILC.
    	</p>
		<h3>Equiv. Photon</h3>
		<p>
			If \"Equiv. Photon\" is chosen for the pdf, then the following parameters may be specified:<br>
			<table>
				<tr><td>Photon particle</td><td>:</td><td>e^-</td></tr>
				<tr><td>|Q|max</td><td>:</td><td>150</td></tr>
			</table>
			Choices for the \"Photon particle\" keyphrase are mu^-, e^-, e^+, mu^+.  The default is e^+.  The default for the keyword \"|Q|max\" is the same as in CalcHEP.
		</p>
		<h3>Proton Photon</h3>
		<p>
			If \"Proton Photon\" is chosen then the following may be specified:<br>
			<table>
				<tr><td>Incoming particle mass</td><td>:</td><td>0.937</td></tr>
				<tr><td>Incoming particle charge</td><td>:</td><td>-1</td></tr>
				<tr><td>|Q^2|max</td><td>:</td><td>2.1</td></tr>
				<tr><td>Pt cut of outgoing proton</td><td>:</td><td>0.11</td></tr>
			</table>
			The defaults are the same as in CalcHEP.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}


sub print_help_momentum {
	print_help_batch_links("$html_dir/help/momentum.html");
	open(HTML_FILE, ">>$html_dir/help/momentum.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Momentum Help</h1>
		<h3>Momentum</h3>
		<p>
			The momentum of the incoming states can be specified with the keywords \"p1\" and \"p2\" and are in GeV as in:<br>
			<table>
				<tr><td>p1</td><td>:</td><td>7000</td></tr>
				<tr><td>p2</td><td>:</td><td>7000</td></tr>
			</table>
			These are the default values for the momenta.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}


sub print_help_parameters {
	print_help_batch_links("$html_dir/help/parameters.html");
	open(HTML_FILE, ">>$html_dir/help/parameters.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Parameter Help</h1>
		<h3>Parameter</h3>
		<p>
			The parameters of the model are taken from the varsN.mdl file in the models directory.  Other parameter values can be used if specified using the \"Parameter\" keyword.  Here is an example:<br>
			<table>
				<tr><td>Parameter</td><td>:</td><td>EE=0.31</td></tr>
				<tr><td>Parameter</td><td>:</td><td>SW=0.481</td></tr>
				<tr><td>Parameter</td><td>:</td><td>MZ=91.1884</td></tr>
				<tr><td>Parameter</td><td>:</td><td>wW=2.08895</td></tr>
			</table>
			Any parameters not specified using this keyword in the batch file will be taken from the varsN.mdl file in the models directory.  This gives a convenient way of changing the default values of the parameters.  Simply open CalcHEP in symbolic mode, choose to edit the model and change the values of the indepenedent parameters.  These new values will then become the default values used by this batch program.  There is no need to redo the process library.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}


sub print_help_runs {
	print_help_batch_links("$html_dir/help/runs.html");
	open(HTML_FILE, ">>$html_dir/help/runs.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Run Help</h1>
		<h3>Runs</h3>
		<p>
			In some models it is useful to run over a parameter such as the mass of one of the new particles.  For example, if there is a new W' gauge boson, it may be desireable to generate events and/or distributions for a range of masses for the W'.  This can be done with the \"Run parameter\", \"Run begin\", \"Run step size\" and \"Run n steps\" keyphrases.  Here is an example:<br>
			<table>
				<tr><td>Run parameter</td><td>:</td><td>MWP</td></tr>
				<tr><td>Run begin</td><td>:</td><td>400</td></tr>
				<tr><td>Run step size</td><td>:</td><td>50</td></tr>
				<tr><td>Run n steps</td><td>:</td><td>17</td></tr>
			</table>
			This will generate the events and/or distributions for the model with the mass of the W' set to 400GeV, 450GeV, 500GeV,...1200GeV.  As many runs as desired can be specified (including zero).  For each run, all four keyphrases have to be specified.  Furthermore, if there is more than one run, all four keyphrases have to be specified together.  Here is an example with two runs:<br>
			<table>
				<tr><td>Run parameter</td><td>:</td><td>MWP</td></tr>
				<tr><td>Run begin</td><td>:</td><td>400</td></tr>
				<tr><td>Run step size</td><td>:</td><td>50</td></tr>
				<tr><td>Run n steps</td><td>:</td><td>17</td></tr>
				<tr><td></td></tr>
				<tr><td>Run parameter</td><td>:</td><td>MF</td></tr>
				<tr><td>Run begin</td><td>:</td><td>2000</td></tr>
				<tr><td>Run step size</td><td>:</td><td>200</td></tr>
				<tr><td>Run n steps</td><td>:</td><td>11</td></tr>
			</table>
			This example will run over both parameters MWP and MF.

		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}



sub print_help_qcd {
	print_help_batch_links("$html_dir/help/qcd.html");
	open(HTML_FILE, ">>$html_dir/help/qcd.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>QCD Help</h1>
		<h3>QCD</h3>
		<p>
			The parameters of the QCD menu of the numerical session can be specified as in the following example:<br>
			<table>
				<tr><td>parton dist. alpha</td><td>:</td><td>ON</td></tr>
				<tr><td>alpha(MZ)</td><td>:</td><td>0.118</td></tr>
				<tr><td>alpha nf</td><td>:</td><td>5</td></tr>
				<tr><td>alpha order</td><td>:</td><td>NLO</td></tr>
				<tr><td>mb(mb)</td><td>:</td><td>4</td></tr>
				<tr><td>Mtop(pole)</td><td>:</td><td>174</td></tr>
				<tr><td>alpha Q</td><td>:</td><td>M45</td></tr>
			</table>
			The default values are the ones in CalcHEP itself.  Not all the keywords have to be included in the batch file.  It is sufficient to include the ones that need to be changed.  For example, if only the QCD scale needs to be changed, it can be specified as:<br>
			<table>
				<tr><td>alpha Q</td><td>:</td><td>Mt/2</td></tr>
			</table>
			The QCD scale can be specified in terms of the invariant mass of certain final state particles as in \"Mij\" which means that the QCD scale is taken to be the invariant mass of particles i and j.  Or, it can be specified as a formula in terms of the parameters of the model as in \"Mt/2\" which means half of the top quark mass.  When specifying the scale in terms of the invariant mass of final state particles, the numbers are taken from the way the processes are entered with the \"Process\" keyword.  So, if the process is specified as \"p,p->j,l,n\", \"M45\" means the invariant mass of the lepton and neutrino (l,n).  The batch script will take care of renumbering if the subprocesses have the final state particles in a different order.  It is also sometimes useful to use a different scale for different processes.  For example, suppose the two processes \"p,p->j,l,n\" and \"p,p->j,j,l,n\" are specified in the batch file, the scales could be specified as in this example:<br>
			<table>
				<tr><td>alpha Q</td><td>:1:</td><td>M45</td></tr>
				<tr><td>alpha Q</td><td>:2:</td><td>M56</td></tr>
			</table>
			The number between the :: specifies which process to apply this scale and corresponds to the order in which the user specified the processes.  If more than one process is specified, but the same non default scale is desired for all of them, this can be specified as in:<br>
			<table>
				<tr><td>alpha Q</td><td>:</td><td>Mt/2</td></tr>
			</table>
			This specification will apply the same scale \"Mt/2\" to all processes.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}




sub print_help_cuts {
	print_help_batch_links("$html_dir/help/cuts.html");
	open(HTML_FILE, ">>$html_dir/help/cuts.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Cuts Help</h1>
		<h3>Cut</h3>
		<p>
			Cuts are specified with the keywords \"Cut parameter\", \"Cut invert\", \"Cut min\" and \"Cut max\" and use standard CalcHEP notation, except for \"Cut invert\" which can be either \"True\" or \"False\".  These cuts are only applied to the production processes.  They are not applied to the products of the decays.  Here is an example:<br>
			<table>
				<tr><td>Cut parameter</td><td>:</td><td>T(le)</td></tr>
				<tr><td>Cut invert</td><td>:</td><td>False</td></tr>
				<tr><td>Cut min</td><td>:</td><td>20</td></tr>
				<tr><td>Cut max</td><td>:</td><td></td></tr>
			</table>
			For each cut, all four keyphrases have to be present.  As many cuts as desired can be included.  Including \"Cut min\" or \"Cut max\" but leaving the value blank will leave the value blank in the CalcHEP table.  If the cut should only be applied to a certain process, then the colon can be changed to :n: where n is the process.  So, for example, we could do:<br>
			<table>
				<tr><td>Cut parameter</td><td>:</td><td>T(l)</td></tr>
				<tr><td>Cut invert</td><td>:</td><td>True</td></tr>
				<tr><td>Cut min</td><td>:</td><td></td></tr>
				<tr><td>Cut max</td><td>:</td><td>20</td></tr>
				<tr><td></td></tr>
				<tr><td>Cut parameter</td><td>:</td><td>T(j)</td></tr>
				<tr><td>Cut invert</td><td>:</td><td>False</td></tr>
				<tr><td>Cut min</td><td>:</td><td>20</td></tr>
				<tr><td>Cut max</td><td>:</td><td></td></tr>
				<tr><td></td></tr>
				<tr><td>Cut parameter</td><td>:2:</td><td>J(j,j)</td></tr>
				<tr><td>Cut invert</td><td>:</td><td>False</td></tr>
				<tr><td>Cut min</td><td>:2:</td><td>0.4</td></tr>
				<tr><td>Cut max</td><td>:2:</td><td></td></tr>
				</table>
			This set of cuts will apply a p<sub>T</sub> cut to leptons and jets in all processes but a jet cone angle cut only to process 2.  The numbering of the processes corresponds to the order in which the processes are entered in the batch file.  Composite particle names can be used as long as they are defined by the keyword \"Composite\" in the process section.  Note that both of the transverse mass cuts apply a p<sub>T</sub>>20GeV cut in this example.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}



sub print_help_kinematics {
	print_help_batch_links("$html_dir/help/kinematics.html");
	open(HTML_FILE, ">>$html_dir/help/kinematics.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Kinematics Help</h1>
		<h3>Kinematics</h3>
		<p>
			As the number of final state particles increases, it can be very helpful to specify the \"kinematics\" which helps CalcHEP in the numerical integration stage.  This is done in exactly the same notation as in CalcHEP.  The numbering corresponds to the order the particles are entered in the process in the batch file.  Here is an example:<br>
			<table>
				<tr><td>Kinematics</td><td>:</td><td>12 -> 34 , 56</td></tr>
				<tr><td>Kinematics</td><td>:</td><td>34 -> 3 , 4</td></tr>
				<tr><td>Kinematics</td><td>:</td><td>56 -> 5 , 6</td></tr>
			</table>
			If multiple processes are specified, using a single colon as in the previous example will apply the kinematics to all processes.  If different kinematics is desired for each process, then the :n: notation can be used as in:<br>
			<table>
				<tr><td>Kinematics</td><td>:1:</td><td>12 -> 34 , 56</td></tr>
				<tr><td>Kinematics</td><td>:1:</td><td>34 -> 3 , 4</td></tr>
				<tr><td>Kinematics</td><td>:1:</td><td>56 -> 5 , 6</td></tr>
				<tr><td></td></tr>
				<tr><td>Kinematics</td><td>:2:</td><td>12 -> 3 , 456</td></tr>
				<tr><td>Kinematics</td><td>:2:</td><td>456 -> 45 , 6</td></tr>
				<tr><td>Kinematics</td><td>:2:</td><td>45 -> 4 , 5</td></tr>
			</table>
			where n corresponds with the process number as entered in the batch file.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}



sub print_help_regularization {
	print_help_batch_links("$html_dir/help/regularization.html");
	open(HTML_FILE, ">>$html_dir/help/regularization.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Regularization Help</h1>
		<h3>Regularization</h3>
		<p>
			When a narrow resonance is present in the signal, it is a good idea to specify the \"regularization\".  This is done with the same notation as in CalcHEP.  Here is an example:<br>
			<table>
				<tr><td>Regularization momentum</td><td>:</td><td>34</td></tr>
				<tr><td>Regularization mass</td><td>:</td><td>MW</td></tr>
				<tr><td>Regularization width</td><td>:</td><td>wW</td></tr>
				<tr><td>Regularization power</td><td>:</td><td>2</td></tr>
			</table>
			Regularization for as many resonances can be specified as desired.  Furthermore, different resonances can be specified for each process using the :n: notation as in:<br>
			
			<table>
				<tr><td>Regularization momentum</td><td>:1:</td><td>34</td></tr>
				<tr><td>Regularization mass</td><td>:1:</td><td>MW</td></tr>
				<tr><td>Regularization width</td><td>:1:</td><td>wW</td></tr>
				<tr><td>Regularization power</td><td>:1:</td><td>2</td></tr>
				<tr><td></td></tr>
				<tr><td>Regularization momentum</td><td>:2:</td><td>45</td></tr>
				<tr><td>Regularization mass</td><td>:2:</td><td>MZ</td></tr>
				<tr><td>Regularization width</td><td>:2:</td><td>wZ</td></tr>
				<tr><td>Regularization power</td><td>:2:</td><td>2</td></tr>
			</table>
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}


sub print_help_distributions {
	print_help_batch_links("$html_dir/help/distributions.html");
	open(HTML_FILE, ">>$html_dir/help/distributions.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Distribution Help</h1>
		<h3>Distributions</h3>
		<p>
			The ability to do distributions is still somewhat experimental so they should be checked carefully.  Distributions are only applied to the production process.  The decays are ignored.  Standard CalcHEP notation is used for the distribution parameter.  Here is an example:<br>
			<table>
				<tr><td>Dist parameter</td><td>:</td><td>M(e,E)</td></tr>
				<tr><td>Dist min</td><td>:</td><td>0</td></tr>
				<tr><td>Dist max</td><td>:</td><td>200</td></tr>
				<tr><td>Dist n bins</td><td>:</td><td>100</td></tr>
				<tr><td>Dist title</td><td>:</td><td>p,p->l,l</td></tr>
				<tr><td>Dist x-title</td><td>:</td><td>M(l,l) (GeV)</td></tr>
			</table>
			The value for the keyphrase \"Dist n bins\" has to be one of:<br>
			<table>
				<tr><td>300</td><td>150</td><td>100</td><td>75</td><td>60</td><td>50</td></tr>
				<tr><td>30</td><td>25</td><td>20</td><td>15</td><td>12</td><td>10</td></tr>
				<tr><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td></tr>
			</table>
			These are the values allowed by the CalcHEP histogram routines.  The values given for the titles have to be pure text.  No special characters are currently allowed.  Gnuplot must be installed for plots to be produced on the fly and included in the html progress reports.  More than one distribution can be specified, however each distribution must be unambiguous and apply in exactly one way for each subprocess.  Also, distributions will work even if no events are requested.
		</p>
		<h3>Possible Issues</h3>
		<p>
		For this to work, the distributions have to be unambiguous and apply to all subprocesses the same way.  For example, if a process is p,p->l,l,l and the distribution M(l,l) is given, then this routine will not know which two leptons to apply the distribution to and the results are unpredictable.  If the process is p,p->l,l where l=e,E,m,M and the distribution M(e,E) is desired, this distribution will only apply to some of the subprocesses and give unpredictable results.  Make sure your distribution is unambiguous and applies in exactly one way to each subprocess.  If this is done, it should work.  Nevertheless, check each distribution carefully to make sure it is being done correctly.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}



sub print_help_events {
	print_help_batch_links("$html_dir/help/events.html");
	open(HTML_FILE, ">>$html_dir/help/events.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Events Help</h1>
		<h3>Number of events</h3>
		<p>
			The number of events is specified with the keyphrase \"Number of events\".  This specifies the number of events to produce after all subprocesses are combined and decayed.  If a run over a parameter is specified, this keyphrase determines the number of events to produce for each value of the run parameter.  The number of events requested can be zero.  In this case, the cross sections are determined and the distributions generated but no events are produced.  Here is an example:<br>
			<table>
				<tr><td>Number of events</td><td>:</td><td>1000</td></tr>
			</table>
		</p>
		<h3>Filename</h3>
		<p>
			The name of the file can be specified using the \"Filename\" keyword.  If specified, all the files will begin with this name.  Here is an example:<br>
			<table>
				<tr><td>Filename</td><td>:</td><td>pp-ll</td></tr>
			</table>
		</p>
		<h3>NTuple</h3>
		<p>
			If nt_maker has been installed in the bin directory, PAW ntuples can be made on the fly by setting \"NTuple\" to True as in:<br>
			<table>
				<tr><td>NTuple</td><td>:</td><td>True</td></tr>
			</table>
			The default is False.
		</p>
		<h3>Cleanup</h3>
		<p>
			If this is set to true, the individual event files are removed after the final event file is created.  This is useful for saving space on the hard drive.  It is True by default.  Here is an example:<br>
			<table>
				<tr><td>Cleanup</td><td>:</td><td>False</td></tr>
			</table>
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}



sub print_help_parallelization {
	print_help_batch_links("$html_dir/help/parallelization.html");
	open(HTML_FILE, ">>$html_dir/help/parallelization.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Parallelization Help</h1>
		<h3>Parallelization Method</h3>
		<p>
			The parallelization mode is set using the keyphrase \"Parallelization method\" and can be either \"local\", \"pbs\" or \"lsf\".  In local mode, the jobs run on the local computer while in pbs mode, the jobs are run on a pbs cluster.  If run from a pbs or lsf cluster, the terminal should be on the computer with the pbs or lsf queue.  Here is an example of setting the batch to run in pbs mode:<br>
			<table>
				<tr><td>Parallelization mode</td><td>:</td><td>pbs</td></tr>
			</table>
			Local mode is the default.
		</p>
		<h3>PBS</h3>
		<p>
		If run in pbs mode, there are several options that may be necessary for the pbs cluster.  All of them can be left blank in which case they will not be given to the pbs cluster.  Here is an example of the options available:<br>
		<table>
			<tr><td>Que</td><td>:</td><td>brody</td></tr>
			<tr><td>Walltime</td><td>:</td><td>1.5</td></tr>
			<tr><td>Memory</td><td>:</td><td>1</td></tr>
			<tr><td>email</td><td>:</td><td>name\@address</td></tr>
		</table>
		The que specifies which pbs que to  submit the jobs to.  Walltime specifies the maximum time (in hours) the job can run for.  If this time is exceeded, the jobs are killed by the pbs cluster.  Memory specifies the maximum amount of memory (in G) that the jobs can use.  If this memory is exceeded by a job, the pbs cluster will kill the job.  email specifies which email to send a message to if the job terminates prematurely.  The default for all of these is whatever is the default on the pbs cluster.
		</p>
		<h3>LSF</h3>
		<p>
		If run in lsf mode, there are several options that may be necessary for the lsf cluster.  All of them can be left blank in which case they will not be given to the lsf cluster.  Here is an example of the options available:<br>
		<table>
			<tr><td>Que</td><td>:</td><td>brody</td></tr>
			<tr><td>Walltime</td><td>:</td><td>1.5</td></tr>
			<tr><td>Memory</td><td>:</td><td>1</td></tr>
			<tr><td>email</td><td>:</td><td>name\@address</td></tr>
                        <tr><td>Project</td><td>:</td><td>project_name</td></tr>
		</table>
		The que specifies which lsf que to  submit the jobs to.  Walltime specifies the maximum time (in hours) the job can run for.  If this time is exceeded, the jobs are killed by the lsf cluster.  Memory specifies the maximum amount of memory (in G) that the jobs can use.  If this memory is exceeded by a job, the lsf cluster will kill the job.  email specifies which email to send any messages t.  The default for all of these is whatever is the default on the lsf cluster.
		</p>
		<h3>Sleep Time</h3>
		<p>
		Sleep time specifies the amount of time (in seconds) the batch script waits before checking which jobs are done and updating the html progress reports.  If a very short test run is being done, then this should be low (say a few seconds).  However, if the job is very large and will take severl hours or days, this should be set very high (say minutes or tens of minutes).  This will reduce the amount of cpu time the batch program uses.  Here is an example setting the sleep time to 1 minute:<br>
		<table>
			<tr><td>sleep time</td><td>:</td><td>60</td></tr>
		</table>
		The default is 3 seconds.
		</p>
		<h3>Nice Level</h3>
		<p>
			When jobs are run on the local computer, this specifies what nice level the jobs should be run at.  If other users are using the same computer, this allows the job to be put into the background and run at lower priority so as not to disturb the other users.  This should be between 0 and 19 where 19 is the lowest priority and the nicest.  Typically, it should be run at level 19 unless the user is sure it will not disturb anyone.  The nice level should be set both for a local computer and for a pbs batch run.  The reason is that some jobs are run on the pbs queue computer even on the pbs cluster.  Here is an example:<br>
			<table>
				<tr><td>Nice level</td><td>:</td><td>19</td></tr>
			</table>
			Level 19 is the default.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}


sub print_help_vegas {
	print_help_batch_links("$html_dir/help/vegas.html");
	open(HTML_FILE, ">>$html_dir/help/vegas.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Vegas Help</h1>
		<h3>Vegas</h3>
		<p>
			The number of vegas calls can be controlled with the keywords \"nSess_1\", \"nCalls_1\", \"nSess_2\" and \"nCalls_2\".  The values are the same as in CalcHEP.  Here is an example:<br>
			<table>
				<tr><td>nSess_1</td><td>:</td><td>5</td></tr>
				<tr><td>nCalls_1</td><td>:</td><td>100000</td></tr>
				<tr><td>nSess_2</td><td>:</td><td>5</td></tr>
				<tr><td>nCalls_2</td><td>:</td><td>100000</td></tr>
			</table>
			The defaults are the same as in CalcHEP.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}



sub print_help_generator {
	print_help_batch_links("$html_dir/help/generator.html");
	open(HTML_FILE, ">>$html_dir/help/generator.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Generator Help</h1>
		<p>
			The following parameters of the event generation can be modified:<br>
			<table>
				<tr><td>sub-cubes</td><td>:</td><td>1000</td></tr>
				<tr><td>random search</td><td>:</td><td>100</td></tr>
				<tr><td>simplex search</td><td>:</td><td>50</td></tr>
				<tr><td>MAX*N</td><td>:</td><td>2</td></tr>
				<tr><td>find new MAX</td><td>:</td><td>100</td></tr>
			</table>
			The defaults are the CalcHEP defaults.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}




sub print_help_example1 {
	print_help_batch_links("$html_dir/help/example1.html");
	open(HTML_FILE, ">>$html_dir/help/example1.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Example 1</h1>
		<p>
			This example generates 1000 events (for each MWP) of the process p,p->W,Z->l,l,l,n.
			<table>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Model Info                     </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Model</td><td>:</td><td>3-Site</td></tr>
				<tr><td>Model changed</td><td>:</td><td>False</td></tr>
				<tr><td>Gauge</td><td>:</td><td>Feynman</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Process Info                   </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Process</td><td>:</td><td>p,p->W,Z</td></tr>
				<tr><td>Decay</td><td>:</td><td>W->l,n</td></tr>
				<tr><td>Decay</td><td>:</td><td>Z->l,l</td></tr>
				<tr><td>Composite</td><td>:</td><td>p=u1,U1,d1,D1,G</td></tr>
				<tr><td>Composite</td><td>:</td><td>W=W+,W-</td></tr>
				<tr><td>Composite</td><td>:</td><td>l=e1,E1,e2,E2</td></tr>
				<tr><td>Composite</td><td>:</td><td>n=n1,N1,n2,N2</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  PDF Info                       </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>pdf1</td><td>:</td><td>cteq6l (proton)</td></tr>
				<tr><td>pdf2</td><td>:</td><td>cteq6l (proton)</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Momentum Info                  </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>p1</td><td>:</td><td>7000</td></tr>
				<tr><td>p2</td><td>:</td><td>7000</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Parameter Info                 </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Parameter</td><td>:</td><td>MF=4000</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Run Info                       </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Run parameter</td><td>:</td><td>MWP</td></tr>
				<tr><td>Run begin</td><td>:</td><td>400</td></tr>
				<tr><td>Run step size</td><td>:</td><td>50</td></tr>
				<tr><td>Run n steps</td><td>:</td><td>17</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Event Info                     </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Number of events</td><td>:</td><td>1000</td></tr>
				<tr><td>Filename</td><td>:</td><td>pp-WZ-llln</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Parallelization Info           </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Parallelization method</td><td>:</td><td>local</td></tr>
				<tr><td>Max number of cpus</td><td>:</td><td>2</td></tr>
				<tr><td>sleep time</td><td>:</td><td>3</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Vegas Info                     </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>nSess_1</td><td>:</td><td>5</td></tr>
				<tr><td>nCalls_1</td><td>:</td><td>100000</td></tr>
				<tr><td>nSess_2</td><td>:</td><td>5</td></tr>
				<tr><td>nCalls_2</td><td>:</td><td>100000</td></tr>
			</table>

			
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}

sub print_help_example2 {
	print_help_batch_links("$html_dir/help/example2.html");
	open(HTML_FILE, ">>$html_dir/help/example2.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Example 2</h1>
		<p>
			This example gives the invariant mass distribution for the two leptons in the final state of p,p->l,l.
			<table>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Model Info                     </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Model</td><td>:</td><td>3-Site</td></tr>
				<tr><td>Model changed</td><td>:</td><td>False</td></tr>
				<tr><td>Gauge</td><td>:</td><td>Feynman</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Process Info                   </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Process</td><td>:</td><td>p,p->l,l</td></tr>
				<tr><td>Composite</td><td>:</td><td>p=u1,U1,d1,D1,G</td></tr>
				<tr><td>Composite</td><td>:</td><td>l=e1,E1,e2,E2</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  PDF Info                       </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>pdf1</td><td>:</td><td>cteq6l (proton)</td></tr>
				<tr><td>pdf2</td><td>:</td><td>cteq6l (proton)</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Momentum Info                  </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>p1</td><td>:</td><td>7000</td></tr>
				<tr><td>p2</td><td>:</td><td>7000</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Parameter Info                 </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Parameter</td><td>:</td><td>MF=4000</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Run Info                       </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Run parameter</td><td>:</td><td>MWP</td></tr>
				<tr><td>Run begin</td><td>:</td><td>400</td></tr>
				<tr><td>Run step size</td><td>:</td><td>50</td></tr>
				<tr><td>Run n steps</td><td>:</td><td>17</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Cut Info                       </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Cut parameter</td><td>:</td><td>T(l)</td></tr>
				<tr><td>Cut min</td><td>:</td><td>20</td></tr>
				<tr><td>Cut max</td><td>:</td><td></td></tr>
				<tr><td></td></tr>
				<tr><td>Cut parameter</td><td>:</td><td>N(l)</td></tr>
				<tr><td>Cut min</td><td>:</td><td>0.4</td></tr>
				<tr><td>Cut max</td><td>:</td><td></td></tr>
				<tr><td></td></tr>
				<tr><td>Cut parameter</td><td>:</td><td>J(l,l)</td></tr>
				<tr><td>Cut min</td><td>:</td><td>0.2</td></tr>
				<tr><td>Cut max</td><td>:</td><td></td></tr>
				<tr><td></td></tr>
				<tr><td>Cut parameter</td><td>:</td><td>M(l,l)</td></tr>
				<tr><td>Cut min</td><td>:</td><td>MWP-100</td></tr>
				<tr><td>Cut max</td><td>:</td><td>MWP+100</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Distribution Info              </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Dist parameter</td><td>:</td><td>M(l,l)</td></tr>
				<tr><td>Dist min</td><td>:</td><td>MWP-100</td></tr>
				<tr><td>Dist max</td><td>:</td><td>MWP+100</td></tr>
				<tr><td>Dist n bins</td><td>:</td><td>100</td></tr>
				<tr><td>Dist title</td><td>:</td><td>p,p->l,l</td></tr>
				<tr><td>Dist x-title</td><td>:</td><td>M(l,l) (GeV)</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Parallelization Info           </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>Parallelization method</td><td>:</td><td>local</td></tr>
				<tr><td>Max number of cpus</td><td>:</td><td>2</td></tr>
				<tr><td>sleep time</td><td>:</td><td>3</td></tr>
				<tr><td></td></tr>
				<tr><td colspan="3">##################################</td>
				<tr><td colspan="3">#  Vegas Info                     </td>
				<tr><td colspan="3">##################################</td>
				<tr><td>nSess_1</td><td>:</td><td>5</td></tr>
				<tr><td>nCalls_1</td><td>:</td><td>100000</td></tr>
				<tr><td>nSess_2</td><td>:</td><td>5</td></tr>
				<tr><td>nCalls_2</td><td>:</td><td>100000</td></tr>
			</table>

		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}

sub print_help_example3 {
	print_help_batch_links("$html_dir/help/example3.html");
	open(HTML_FILE, ">>$html_dir/help/example3.html");
	print HTML_FILE <<ENDHTML;
	<div id='help_main'>
		<h1>Example 3</h1>
		<p>
			
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}





sub print_help_process_library {
	open(HTML_FILE, ">$html_dir/help/process_library.html");
	print HTML_FILE <<ENDHTML;
<html>
<head>
	<title>CalcHEP Batch Help</title>
	<link rel='stylesheet' href='../style.css' type='text/css'></link>
</head>
<body>
	<div id='links'>
		<ul>
			<li><a href='../index.html'>Home</a></li>
			<li><a href='../symbolic.html'>Symbolic Results</a></li>
			<li><a href='../numerical.html'>Numerical Results</a></li>
			<li><a href='../events.html'>Events Library</a></li>
			<li><a href='../library.html'>Process Library</a></li>
			<li><a href='index.html'>Help</a>
				<ul>
					<li><a href='batch_file.html'>Batch File</a></li>
					<li><a href='process_library.html'>Process Library</a></li>
					<li><a href='event_library.html'>Event Library</a></li>
				</ul>
			</li>
			<br>
			<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>
			<li>Please cite <a href=''>arXiv:0000.0000</a></li>
		</ul>
	</div>	
	<div id='help_main'>
		<h1>Process Library Help</h1>
		<p>
			After the numerical code is generated for a process, it is stored in the \"Process Library\".  If the same process is used later, it is first looked for in the process library.  If it is there, the symbolic session is skipped and it is used again in the numerical stage.  This can save significant time.  If the model is changed, this process library needs to be regenerated.  This is done by deleting the directory corresponding to the model in the Processes directory.  The full path to this directory can be obtained by setting the keyphrase \"Model changed\" to True in the batch file and running the batch program on it.  The full path will appear in the html progress files.  If the only change made to a model is the numerical values of the independent parameters, there is no need to recreate the process library.  The numerical values of the parameters are always taken from the model files by default.  A change to these values is automatically updated.
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}

sub print_help_event_library {
	open(HTML_FILE, ">$html_dir/help/event_library.html");
	print HTML_FILE <<ENDHTML;
<html>
<head>
	<title>CalcHEP Batch Help</title>
	<link rel='stylesheet' href='../style.css' type='text/css'></link>
</head>
<body>
	<div id='links'>
		<ul>
			<li><a href='../index.html'>Home</a></li>
			<li><a href='../symbolic.html'>Symbolic Results</a></li>
			<li><a href='../numerical.html'>Numerical Results</a></li>
			<li><a href='../events.html'>Events Library</a></li>
			<li><a href='../library.html'>Process Library</a></li>
			<li><a href='index.html'>Help</a>
				<ul>
					<li><a href='batch_file.html'>Batch File</a></li>
					<li><a href='process_library.html'>Process Library</a></li>
					<li><a href='event_library.html'>Event Library</a></li>
				</ul>
			</li>
			<br>
			<li>Thank you for using <a href='http://theory.sinp.msu.ru/~pukhov/calchep.html'>CalcHEP</a>!</li>
			<li>Please cite <a href=''>arXiv:0000.0000</a></li>
		</ul>
	</div>	
	<div id='help_main'>
		<h1>Event Library Help</h1>
		<p>
			After the events and/or distributions are generated, they are stored in the Events directory.  The prefix of the files is the name specified in the batch file plus either "-single" if no runs were specified or a string specifying the run parameter values if one or more runs are specified.  We will assume this is filename in the following.  If events are requested, they will be stored in the files<br>
			<table>
				<tr><td>filename.lhe</td></tr>
				<tr><td>filename.nt</td></tr>
			</table>
			where filename.lhe is the event file in Les Houches format and filename.nt is in PAW ntuple format.  The ntuple file is only created if the keyword "NTuple" is set to true and nt_maker is present in the bin directory.  If distributions are requested, they will be  stored in the files<br>
			<table>
				<tr><td>filename.distr</td></tr>
				<tr><td>filename_1.png</td></tr>
				<tr><td>filename_2.png</td></tr>
				<tr><td>...</td></tr>
			</table>
			  where filename.distr is the raw distribution data and can be read by "show_distr" in the bin directory.  The distributions generated on the fly by the batch script are stored in the files ending in ".png".
		</p>
	</div>
</body>
</html>
ENDHTML
	close(HTML_FILE);
}



